\part{Introduction}% Prendre l'intro de ``intro-tres-bien.pdf'' -> 1h% Prendre l'intro à Fibonacci de ... pour introduire la récurrence et% montrer la différence entre un algorithme efficace et un pas% efficace. Prendre aussi l'exemple de la factorielle de Boigelot. ->% 1h% A dire au premier cours -> prendre le cours de % - Motiver avec des exemples concrets (google) -> voir les slides de Bernard ou autres. Internet, etc.%   (voir intro-pas-mal.ppt dans le répertoire resources)% - Définir algorithme% - Donner un exemple: le tri par insertion -> permet de décrire le pseudo-code (dire que je le ferai en anglais et que je me permettrai d'utiliser des termes anglais aussi lors de la présentation. En préparant le cours, j'ai eu beaucoup de mal à retrouver les correspondances avec certains termes anglais)% - Parler des structures de données, parler de l'interface, donner un exemple (liste liée !! Dire que c'est à la fois un type de données abstraits et aussi une implémentation particulière en C -> implémentation avec un pointeur)% % Passer en revue ce qu'on va voir au cours% Introduire analyse de complexité + récurrence.% Fibonacci -> introduction aux récurrences (Carzinaga)% % - Prendre un exemple pour montrer qu'on peut gagner énormément en utilisant une implémentation non naïve et % - Passer en revue toutes les structures de données et les algorithmes qu'on verra dans la suite% - Détailler et expliquer la structure du cours% - Voir le bouquin allemand qui revisite la multiplication !!!% - Voir les slides dans le répertoire resources\section{Algorithms $+$ Data structures $=$ Programs}\begin{frame}{Plan}\tableofcontents\end{frame}\begin{frame}{Introduction}% Ulrich Klehmet\begin{itemize}\item Qu'est-ce qu'une structure de données ?\item Qu'est-ce qu'un algorithme ?\item Pourquoi étudier les deux ensemble ?\item Comment peut-on déterminer l'utilité d'une certaine combinaison de structures de données et d'algorithmes ?\end{itemize}\end{frame}\begin{frame}{Algorithmes}\begin{itemize}\item Un {\bf algorithme} est une suite {\em finie} et {\em non-ambiguë} d'opérations ou d'instructions permettant de résoudre un {\em problème}\item Provient du nom du mathématicien persan {\em Al-Khawarizmi}  ($\pm 820$), le père de l'algèbre\item Un problème algorithmique est souvent formulé comme la  transformation d'un ensemble de valeurs, {\bf d'entrée}, en un  nouvel ensemble de valeurs, {\bf de sortie}.\item Exemple d'algorithmes:\begin{itemize}\item Recette de cuisine (ingrédients $\rightarrow$ plat préparé)\item Recherche dans un dictionnaire (mot $\rightarrow$ définition)\item La division de l'école primaire (deux entiers $\rightarrow$ leur quotient)\item le problème du tri (séquence $\rightarrow$ séquence ordonnée)%% \begin{itemize}%% \item Entrée = une séquence de $n$ nombres $(a_1,a_2,\ldots,a_n)$%% \item Sortie = une permutation (réarrangement) $(a'_1,a'_2,\ldots,a'_n)$ de la séquence d'entrée telle que $a'_1\leq a'_2\leq \ldots\leq a'_n$.%% \end{itemize}\end{itemize}\end{itemize}\note{dictionnaire: structure de donnée: le dictionnaire: mots écrits  en français et surtout, classés par ordre alphabétique}\end{frame}\begin{frame}{Algorithmes}\begin{itemize}\item On étudiera essentiellement les algorithmes corrects.\begin{itemize}\item Un algorithme est {\em correct} lorsque pour chaque instance, il se termine en produisant la bonne sortie.\end{itemize}\item Un algorithme incorrect peut ne pas se terminer ou renvoyer une réponse incorrecte.\item Un algorithme incorrect peut être parfois utile, si son taux d'erreurs est contrôlé.\bigskip\item Un algorithme peut être spécifié de différentes manières:\begin{itemize}\item en langage naturel,\item graphiquement,\item en pseudo-code,\item par un programme écrit dans un langage informatique...\end{itemize}La seule condition est que la description soit précise.\end{itemize}%% \item doit formulé de manière si précise qu'il peut être exécuté sur une machine.%% \item doit être formulé de manière si préciseIl doit finalement se terminer%% \item Complet. Toujours donner une solution lorsqu'il en existe une.%% \item Correct. Toujours donner une solution ``correcte''.%% \end{itemize}%% \item Pour qu'un algorithme soit une solution envisageable à un%%   problème, il doit aussi être efficace, c'est-à-dire donner une%%   solution en un temps raisonnable.%% \item Il peut y avoir beaucoup algorithmes pour résoudre le même problème.%% \end{itemize}%\item Généralement décrit en utilisant un langage de programmation%  mais cela pourrait être fait en français directement\end{frame}% objectif: présenter le pseudo-code\begin{frame}{Exemple: le tri}\begin{itemize}\item Le problème de tri:\begin{itemize}\item Entrée: une séquence de $n$ nombres $\langle a_1,a_2,\ldots,a_n\rangle$\item Sortie: une permutation de la séquence de départ $\langle a_1',a_2',\ldots,a_n'\rangle$ telle que $a_1'\leq a_2'\leq\ldots\leq a_n'$\end{itemize}\bigskip\item Exemple:\begin{itemize}\item Input: $\langle 31,41,59,26,41,58\rangle$\item Output: $\langle 26,31,41,41,58,59\rangle$\end{itemize}\end{itemize}\end{frame}\begin{frame}{Tri par insertion}\hfill\includegraphics[height=3cm]{Figures/CLRS/Fig-2-1.pdf}Description en langage naturel:\bigskipOn parcourt la séquence en considérant les éléments un par un\bigskipPour chaque élément:\begin{itemize}\item On l'{\textcolor{blue}{insère}} à sa position dans une nouvelle séquence contenant les éléments déjà ordonnés\end{itemize}On s'arrête dès que le dernier élément a été inséré à sa place dans la séquence.\end{frame}\begin{frame}{Tri par insertion}\centerline{\includegraphics[width=8cm]{Figures/01-insertionsort.pdf}}\end{frame}\begin{frame}{Insertion sort}Description en C (sur des tableaux d'entiers):\fcolorbox{white}{lightgray}{\begin{codebox}\end{codebox}}\end{frame}%% \begin{frame}{insertion sort}%% Description en {\bf pseudo-code} (sur des tableaux d'entiers):%% \bigskip%% \end{frame}\begin{frame}{Pseudo-code}objectifs:\begin{itemize}\item décrire les algorithmes de manière à ce qu'il soit comprispar des humains.~\\\item rendre la description indépendante de l'implémentation~\\\item permet de s'affranchir de la gestion d'erreurs, des déclarations de type, etc.\end{itemize}~\\très proche du c (langage procédural plutôt qu'orienté objet)~\\peut contenir certaines instructions en langage naturel si nécessaire% donner quelques règles de pseudo-code\end{frame}\begin{frame}{Trois questions récurrentes}\begin{enumerate}\item Mon algorithme est-il correct ? %\textcolor{darkred}{oui}\bigskip\item Quelle est sa vitesse d'exécution ? %\textcolor{darkred}{$o(n^2)$}\bigskip\item Y-a-t'il moyen de faire mieux ? %\textcolor{darkred}{oui}\end{enumerate}\bigskipExemple du \textcolor{darkred}{tri par insertion}:\begin{enumerate}\item oui $\rightarrow$ technique des invariants (partie 2)\item $o(n^2)$ $\rightarrow$ analyse de complexité (partie 2)\item oui $\rightarrow$ il existe un algorithme $o(n\log n)$ (un peu plus tard)\end{enumerate}% commenter sur la facilité de répondre à ces questions\end{frame}%% \begin{frame}{pourquoi les deux ?}%% coucou%% \end{frame}%% mettre à dans le chapitre sur les structures élémentaires (ou bien lors de l'introductuion du heap, ou bien à la fin de cette section%% dire qu'on va reprendre le problème de l'insertion sort et du merge%% sort pour illustrer les concepts suivants:% - amélioration des performances% - récurrence% - divide and conquer% - complexité en nb d'opération% - %% \begin{frame}{type de données abstraits (tda)}%% un type de données abstrait (tda) représente l'interface d'une structure de données.%% un tda spécifie précisément :%% \begin{itemize}%% \item la nature et les propriétés des données gérées;%% \item les modalités d utilisation des opérations pouvant être effectuées.%% en particulier, un tda décrit généralement :%% \begin{itemize}%% \item de quelle(s) façon(s) un nouvel exemplaire de la structure de%% données peut être créé (instanciation de la structure);%% \item pour chaque opération: quels en sont les param`etres, les effets sur les données gérées, les valeurs de retour éventuelles, et leur comportement en cas d erreur.%% \end{itemize}%% \end{itemize}%% en général, un tda admet différentes implémentations (plusieurs%% représentations possibles des données, plusieurs algorithmes pour les%% opérations).%% \end{frame}\begin{frame}{structures de données}\begin{itemize}\item méthode pour stoquer et organiser les données pour en faciliter  l'accés et la modification\item une structure de données regroupe:\begin{itemize}\item un certain nombre de données à gérer, et\item un ensemble d'opérations pouvant être appliquées à ces données\end{itemize}\end{itemize}\end{frame}\begin{frame}{exemple: listes liées}a la fois un type de donnée abstrait et une implémentation particulière\end{frame}\begin{frame}{exemples de problèmes algorithmiques réels}% voir slides de sedgewick, intro-pas-mal.ppt\begin{itemize}\item google: accéder: très friand en structure de données. index inversé pour arriver à une page\item routage: trouver le plus court chemin entre deux noeuds dans un réseau\item bioinformatique: un des problèmes cruciaux: trouver une sous-séquence dans une masse incroyable de séquences: problèmes de programmation dynamique sur des strings\end{itemize}\end{frame}\section{introduction à la récurrence}% dans cette section, on va parler de fibonacci et proposer une version récurrente% on va parler de la tail-récurrence% commencer par la factorielle% décrire ensuite le merge sort% ne pas détailler le coût associé au merge (on le fera dans la chapitre suivant)% juste conclure sur une comparaison entre insertion sort et merge sort% (pour montrer qu'il y a une énorme différence entre les deux)\begin{frame}{récurrence/récursion}fonction qui s'appelle elle-même\bigskippourquoi ? code plus compact et plus éléguant\bigskipexemple: calcul de la factorielle\end{frame}\begin{frame}{factorielle}\begin{itemize}\item on doit définir un cas de base\item on doit diminuer la ``taille'' du problème à chaque étape\item les sous-problèmes adressés ne doivent pas se superposer\end{itemize}\end{frame}\begin{frame}{fibonacci}\end{frame}\begin{frame}{tri par fusion}idée d'un tri basé sur la récursion:\begin{itemize}\item on sépare la liste en deux sous-listes de la même taille\item on trie (récursivement) chaque des sous-listes\item on fusionne les deux sous-listes triées pour en faire une seule triée également\end{itemize}cas de base: la liste est de taille 1: on renvoiexemple d'application du principe de ``diviser pour régner'' \note{ce principe reviendra souvent dans ce cours}\end{frame}\begin{frame}{tri par fusion: algorithme}\begin{center}\fcolorbox{white}{lightgray}{%    \begin{codebox}      \procname{$\proc{merge-sort}(a,p,r)$}      \li \if $\id{p}<\id{r}$      \li \then $q \gets \frac{p+q}{2}$      \li       $\proc{merge-sort}(a,p,q)$      \li       $\proc{merge-sort}(a,q+1,r)$      \li       $\proc{merge}(a,p,q,r)$ \end    \end{codebox}}\end{center}\end{frame}\begin{frame}{fusion}Utiliser un pointeur vers le début de chacune des listesChoisir le plus petit des deux éléments déplacer cet élément vers letableau fusionné avance le pointeur correspondantFonction prenant en entrées deux tableaux triés et renvoyant untableau avec la fusion des deux.Donner une solutionExpliquer qu'elle nécessite de créer une copie de la table. Essayer devenir avec une version qui ne crée pas cette table n'est pas évident.\end{frame}\begin{frame}{Fusion: algorithme}\begin{center}   \fcolorbox{white}{Lightgray}{    \begin{codebox}      \Procname{$\proc{Merge}(A,p,q,r)$}      \li $n_1 = q-p+1$; $n2 = r-q$      \li let $L[1..n_1+1]$ and $R[1..n_2+1]$ be new arrays      \li \For $i=1$ \To $n_1$      \li $L[i]=A[p+i-1]$      \li \For $j=1$ \To $n_1$      \li $R[j]=A[q+j]$      \li $L[n_1+1]=\infty$; $R[n_2+1]=\infty$      \li i=1;j=1      \li $\proc{Merge-Sort}(A,p,q)$      \li $\proc{Merge-Sort}(A,q+1,r)$      \li $\proc{Merge}(A,p,q,r)$    \end{codebox}}\end{center}\end{frame}\begin{frame}{Comparaison empirique des méthodes de tri}On verra la semaine prochaine comment calculer la complexité de cette méthode.Voyons empiriquement ce que ça donne en comparaison avec insertionsort(déjà trié, pas trié, moyenne sur tableaux aléatoires).Mettre une figure avec une comparaison des temps de calcul\note{Dans un prochain cours, on verra que le tri par fusion est  optimal en terme de temps de calcul (N log N)}\end{frame}