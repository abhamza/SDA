\part{Introduction}% Prendre l'intro de ``intro-tres-bien.pdf'' -> 1h% Prendre l'intro à Fibonacci de ... pour introduire la récurrence et% montrer la différence entre un algorithme efficace et un pas% efficace. Prendre aussi l'exemple de la factorielle de Boigelot. ->% 1h% A dire au premier cours -> prendre le cours de % - Motiver avec des exemples concrets (google) -> voir les slides de Bernard ou autres. Internet, etc.%   (voir intro-pas-mal.ppt dans le répertoire resources)% - Définir algorithme% - Donner un exemple: le tri par insertion -> permet de décrire le pseudo-code (dire que je le ferai en anglais et que je me permettrai d'utiliser des termes anglais aussi lors de la présentation. En préparant le cours, j'ai eu beaucoup de mal à retrouver les correspondances avec certains termes anglais)% - Parler des structures de données, parler de l'interface, donner un exemple (liste liée !! Dire que c'est à la fois un type de données abstraits et aussi une implémentation particulière en C -> implémentation avec un pointeur)% % Passer en revue ce qu'on va voir au cours% Introduire analyse de complexité + récurrence.% Fibonacci -> introduction aux récurrences (Carzinaga)% % - Prendre un exemple pour montrer qu'on peut gagner énormément en utilisant une implémentation non naïve et % - Passer en revue toutes les structures de données et les algorithmes qu'on verra dans la suite% - Détailler et expliquer la structure du cours% - Voir le bouquin allemand qui revisite la multiplication !!!% - Voir les slides dans le répertoire resources\section{Algorithms $+$ Data structures $=$ Programs}\begin{frame}{Plan}\tableofcontents\end{frame}\begin{frame}{Introduction}% Ulrich Klehmet\begin{itemize}\item Qu'est-ce qu'une structure de données ?\item Qu'est-ce qu'un algorithme ?\item Pourquoi étudier les deux ensemble ?\item Comment peut-on déterminer l'utilité d'une certaine combinaison de structures de données et d'algorithmes ?\end{itemize}\end{frame}\begin{frame}{Algorithmes}\begin{itemize}\item Un {\bf algorithme} est une suite {\em finie} et {\em non-ambiguë} d'opérations ou d'instructions permettant de résoudre un {\em problème}\item Provient du nom du mathématicien persan {\em Al-Khawarizmi}  ($\pm 820$), le père de l'algèbre\item Un problème algorithmique est souvent formulé comme la  transformation d'un ensemble de valeurs, {\bf d'entrée}, en un  nouvel ensemble de valeurs, {\bf de sortie}.\item Exemple d'algorithmes:\begin{itemize}\item Recette de cuisine (ingrédients $\rightarrow$ plat préparé)\item Recherche dans un dictionnaire (mot $\rightarrow$ définition)\item La division de l'école primaire (deux entiers $\rightarrow$ leur quotient)\item le problème du tri (séquence $\rightarrow$ séquence ordonnée)%% \begin{itemize}%% \item Entrée = une séquence de $n$ nombres $(a_1,a_2,\ldots,a_n)$%% \item Sortie = une permutation (réarrangement) $(a'_1,a'_2,\ldots,a'_n)$ de la séquence d'entrée telle que $a'_1\leq a'_2\leq \ldots\leq a'_n$.%% \end{itemize}\end{itemize}\end{itemize}\note{dictionnaire: structure de donnée: le dictionnaire: mots écrits  en français et surtout, classés par ordre alphabétique}\end{frame}\begin{frame}{Algorithmes}\begin{itemize}\item On étudiera essentiellement les algorithmes {\bf corrects}.\begin{itemize}\item Un algorithme est {\em correct} lorsque pour chaque instance, il se termine en produisant la bonne sortie.\item Un algorithme incorrect peut ne pas se terminer ou renvoyer une réponse incorrecte.\item Un algorithme incorrect peut être parfois utile, si son taux d'erreurs est contrôlé.\end{itemize}\bigskip\item Les algorithmes seront évalués en termes d'{\em utilisation de resources}, essentiellement {\bf temps de calcul} mais aussi utilisation de la {\bf mémoire}.\end{itemize}\end{frame}\begin{frame}{Algorithmes}Un algorithme peut être spécifié de différentes manières:\begin{itemize}\item en langage naturel,\item graphiquement,\item en pseudo-code,\item par un programme écrit dans un langage informatique...\end{itemize}La seule condition est que la description soit précise.%% \item doit formulé de manière si précise qu'il peut être exécuté sur une machine.%% \item doit être formulé de manière si préciseIl doit finalement se terminer%% \item Complet. Toujours donner une solution lorsqu'il en existe une.%% \item Correct. Toujours donner une solution ``correcte''.%% \end{itemize}%% \item Pour qu'un algorithme soit une solution envisageable à un%%   problème, il doit aussi être efficace, c'est-à-dire donner une%%   solution en un temps raisonnable.%% \item Il peut y avoir beaucoup algorithmes pour résoudre le même problème.%% \end{itemize}%\item Généralement décrit en utilisant un langage de programmation%  mais cela pourrait être fait en français directement\end{frame}% objectif: présenter le pseudo-code\begin{frame}{Exemple: le tri}\begin{itemize}\item Le problème de tri:\begin{itemize}\item Entrée: une séquence de $n$ nombres $\langle a_1,a_2,\ldots,a_n\rangle$\item Sortie: une permutation de la séquence de départ $\langle a_1',a_2',\ldots,a_n'\rangle$ telle que $a_1'\leq a_2'\leq\ldots\leq a_n'$\end{itemize}\bigskip\item Exemple:\begin{itemize}\item Input: $\langle 31,41,59,26,41,58\rangle$\item Output: $\langle 26,31,41,41,58,59\rangle$\end{itemize}\end{itemize}\end{frame}\begin{frame}{Tri par insertion}\hfill\includegraphics[height=3cm]{Figures/CLRS/Fig-2-1.pdf}Description en langage naturel:% PRENDRE LA DESCRIPTION DANS LE BOUQUIN CLRS\bigskipOn parcourt la séquence de gauche à droite\bigskipPour chaque élément $a_j$:\begin{itemize}\item On l'{\alert{insère}} à sa position dans une nouvelle séquence ordonnée contenant les éléments le précédant dans la séquence.\end{itemize}On s'arrête dès que le dernier élément a été inséré à sa place dans la séquence.\end{frame}\begin{frame}\frametitle{Tri par insertion}\centerline{\includegraphics[width=8cm]{Figures/01-insertionsort.pdf}}\end{frame}\begin{frame}[fragile]\frametitle{Insertion sort}Description en C (sur des tableaux d'entiers):%\fcolorbox{white}{Lightgray}{{\small\begin{verbatim}void InsertionSort (int *a, int length) {  int key;  for(int j = 1; i < length; i++) {    key = a[j];    /* Insert a[j] into the sorted sequence a[0...j-1] */    i = j-1;    while (i>0 && a[i]>key) {      a[i+1] = a[i];      i = i-1;    }    a[i+1] = key;  }}\end{verbatim}}\end{frame}\begin{frame}{Insertion sort}Description en {\bf pseudo-code} (sur des tableaux d'entiers):\bigskip\fcolorbox{white}{Lightgray}{\begin{codebox}\Procname{$\proc{Insertion-Sort}(A)$}\li \For $j \gets 2$ \To $\attrib{A}{length}$\li     \Do$\id{key} \gets A[j]$\li \Comment Insert $A[j]$ into the sorted sequence    $A[1 \twodots j-1]$.\li $i \gets j-1$\li \While $i > 0$ and $A[i] > \id{key}$\li   \Do        $A[i+1] \gets A[i]$\li        $i \gets i-1$    \End\li $A[i+1] \gets \id{key}$\End\end{codebox}}\end{frame}\begin{frame}{Pseudo-code}Objectifs:\begin{itemize}\item décrire les algorithmes de manière à ce qu'il soit comprispar des humains.~\\\item rendre la description indépendante de l'implémentation~\\\item s'affranchir de détails tels que la gestion d'erreurs, les déclarations de type, etc.\end{itemize}~\\Très proche du c (langage procédural plutôt qu'orienté objet)~\\Peut contenir certaines instructions en langage naturel si nécessaire% donner quelques règles de pseudo-code\end{frame}\begin{frame}{Pseudo-code}Quelques règles\begin{itemize}\item Structures de blocs indiquées par l'indentation\item Boucles (for, while, repeat) et conditions (if, then, else) comme en C. Compteur de boucle garde sa valeur à la sortie de la boucle.\item Commentaires indiqués par $\Comment$\item Assignation ($\gets$) et test d'égalité ($\isequal$) comme en C.\item Les variables ($i$, $j$ et $key$ par exemple) sont locales à la fonction.\item $A[i]$ désigne l'élément $i$ du tableau $A$. $A[i..j]$ désigne un intervalle de valeurs dans un tableau.\item Des objets peuvent avoir des attributs. Attribut $attr$ de l'objet $x$ est dénoté $x.attr$ ($x$-$>$$attr$ en C).\item Paramètres passés par valeur comme en C.\item ...\end{itemize}\end{frame}\begin{frame}{Trois questions récurrentes face à un algorithme}\begin{enumerate}\item Mon algorithme est-il correct, se termine-t-il ? %\textcolor{darkred}{oui}\bigskip\item Quelle est sa vitesse d'exécution ? %\textcolor{darkred}{$o(n^2)$}\bigskip\item Y-a-t'il moyen de faire mieux ? %\textcolor{darkred}{oui}\end{enumerate}\bigskipExemple du \textcolor{darkred}{tri par insertion}\begin{enumerate}\item Oui $\rightarrow$ technique des invariants (partie 2)\item $O(n^2)$ $\rightarrow$ analyse de complexité (partie 2)\item Oui $\rightarrow$ il existe un algorithme $O(n\log n)$ (partie 1)\end{enumerate}% commenter sur la facilité de répondre à ces questions\note{On va passer en revue rapidement ces trois points pour l'insertion-sort. On reviendra sur ça la semaine prochaine}\end{frame}\begin{frame}{Correction de $\proc{Insertion-Sort}$}\begin{center}\fcolorbox{white}{Lightgray}{\begin{codebox}\Procname{$\proc{Insertion-Sort}(A)$}\li \For $j \gets 2$ \To $\attrib{A}{length}$\li     \Do$\id{key} \gets A[j]$\li $i \gets j-1$\li \While $i > 0$ and $A[i] > \id{key}$\li   \Do        $A[i+1] \gets A[i]$\li        $i \gets i-1$    \End\li $A[i+1] \gets \id{key}$\End\end{codebox}}\end{center}\bigskip\begin{itemize}\item \alert{Invariant:} (pour la boucle externe) le sous-tableau $A[1\twodots j-1]$ contient les éléments du tableau original $A[1\twodots j-1]$ ordonnés.\item On doit montrer que\begin{itemize}\item l'invariant est vrai avant la première itération ({\em intialisation})\item l'invariant est vrai avant chaque itération suivante ({\em maintenance})\item En sortie de boucle, l'invariant implique que l'algorithme est correct ({\em terminaison})\end{itemize}\end{itemize}\note{Si c'est vrai à la terminaison, alors on aura montrer que le tableau est trié à la fin}\end{frame}\begin{frame}{Correction de $\proc{Insertion-Sort}$}\begin{itemize}\item Initialisation:\begin{itemize}\item $j=2 \Rightarrow A[1]$ est trivialement ordonné.\end{itemize}\bigskip\item Maintenance:\begin{itemize}\item Informellement, la boucle interne déplace $A[j-1]$, $A[j-2]$, $A[j-3]\ldots$ d'une position vers la droite jusqu'à la bonne position pour $key$ ($A[j]$).\end{itemize}\bigskip\item Terminaison:\begin{itemize}\item A la sortie de boucle, $j=A.length-1$. L'invariant implique que $A[1\twodots A.length]$ est ordonné.\end{itemize}\end{itemize}\end{frame}\begin{frame}{Complexité de $\proc{Insertion-Sort}$}\begin{center}\fcolorbox{white}{Lightgray}{\begin{codebox}\Procname{$\proc{Insertion-Sort}(A)$}\li \For $j \gets 2$ \To $\attrib{A}{length}$\li     \Do$\id{key} \gets A[j]$\li $i \gets j-1$\li \While $i > 0$ and $A[i] > \id{key}$\li   \Do        $A[i+1] \gets A[i]$\li        $i \gets i-1$    \End\li $A[i+1] \gets \id{key}$\End\end{codebox}}\end{center}\bigskip\begin{itemize}\item Nombre de comparaisons $T(n)$ pour trier un tableau de taille $n$?\item Dans le pire des cas:\begin{itemize}\item La boucle $\For$ est exécutée $n-1$ fois ($n=A.length$).\item La boucle $\While$ est exécutée $j-1$ fois\end{itemize}\end{itemize}\end{frame}\begin{frame}{Complexité de $\proc{Insertion-Sort}$}\begin{itemize}\item Le nombre de comparaisons est borné par:$$T(n)\leq \sum_{j=2}^n (j-1)$$\item Puisque $\sum_{i=1}^n i=i(i+1)/2$, on a:$$T(n)\leq\frac{n(n-1)}{2}$$\item Finalement, $T(n)=O(n^2)$\end{itemize}\bigskip(borne inférieure ?)\end{frame}%% \begin{frame}{pourquoi les deux ?}%% coucou%% \end{frame}%% mettre à dans le chapitre sur les structures élémentaires (ou bien lors de l'introductuion du heap, ou bien à la fin de cette section%% dire qu'on va reprendre le problème de l'insertion sort et du merge%% sort pour illustrer les concepts suivants:% - amélioration des performances% - récurrence% - divide and conquer% - complexité en nb d'opération% - %% \begin{frame}{type de données abstraits (tda)}%% un type de données abstrait (tda) représente l'interface d'une structure de données.%% un tda spécifie précisément :%% \begin{itemize}%% \item la nature et les propriétés des données gérées;%% \item les modalités d utilisation des opérations pouvant être effectuées.%% en particulier, un tda décrit généralement :%% \begin{itemize}%% \item de quelle(s) façon(s) un nouvel exemplaire de la structure de%% données peut être créé (instanciation de la structure);%% \item pour chaque opération: quels en sont les param`etres, les effets sur les données gérées, les valeurs de retour éventuelles, et leur comportement en cas d erreur.%% \end{itemize}%% \end{itemize}%% en général, un tda admet différentes implémentations (plusieurs%% représentations possibles des données, plusieurs algorithmes pour les%% opérations).%% \end{frame}\begin{frame}{Structures de données}\begin{itemize}\item Méthode pour stoquer et organiser les données pour en faciliter  l'accés et la modification\item Une structure de données regroupe:\begin{itemize}\item un certain nombre de données à gérer, et\item un ensemble d'opérations pouvant être appliquées à ces données\end{itemize}\item Dans la plupart des cas, il existe\begin{itemize}\item plusieurs manières de représenter les données et\item différents algorithmes de manipulation.\end{itemize}\item On distingue généralement l'\alert{interface} des structures de  leur implémentation.\end{itemize}\end{frame}\begin{frame}{Types de données abstraits}\begin{itemize}\item Un type de données abstrait (TDA) représente l'interface d'une structure de données.\item Un TDA spécifie précisément:\begin{itemize}\item la nature et les propriétés des données\item les modalités d'utilisation des opérations pouvant être effectuées\end{itemize}\item En général, un TDA admet différentes implémentations (plusieurs représentations possibles des données, plusieurs algorithmes pour les opérations).\end{itemize}\end{frame}\begin{frame}{Exemple: file à priorités}\begin{itemize}\item Données gérées: des objets avec comme attributs:\begin{itemize}\item une clé, munie d'un opérateur de comparaison selon un ordre total\item une valeur quelconque\end{itemize}\medskip\item Opérations:\begin{itemize}\item Création d'une file vide\item $\proc{Insert}(S,x)$: insère l'élément $x$ dans la file $S$.%\item $\proc{Maximum}(S)$: renvoie l'élément de $S$ avec la clé la plus grande.\item $\proc{Extract-Max}(S)$: retire et renvoie l'élément de $S$ avec  la clé la plus grande.\end{itemize}\medskip\item Il existe de nombreuses façons d'implémenter ce TDA:\begin{itemize}\item Tableau non trié;\item Liste triée;\item Structure de tas;\item $\ldots$\end{itemize}Chacune mène à des complexités différentes des opérations $\proc{Insert}$ et $\proc{Extract-Max}$\end{itemize}\end{frame}\begin{frame}{Exemples de problèmes algorithmiques réels}% voir slides de sedgewick, intro-pas-mal.ppt\begin{itemize}\item google: accéder: très friand en structure de données. index inversé pour arriver à une page\item routage: trouver le plus court chemin entre deux noeuds dans un réseau\item bioinformatique: un des problèmes cruciaux: trouver une sous-séquence dans une masse incroyable de séquences: problèmes de programmation dynamique sur des strings\end{itemize}\end{frame}\section{Introduction à la récurrence}% dans cette section, on va parler de fibonacci et proposer une version récurrente% on va parler de la tail-récurrence% commencer par la factorielle% décrire ensuite le merge sort% ne pas détailler le coût associé au merge (on le fera dans la chapitre suivant)% juste conclure sur une comparaison entre insertion sort et merge sort% (pour montrer qu'il y a une énorme différence entre les deux)% (bouquin de Sedgewick)\begin{frame}{Algorithmes récursifs}Une procédure est {\bf récursive} si elle s'invoque elle-mêmedirectement ou indirectement.\bigskipMotivation: Simplicité d'expression de certains algorithmes\bigskipExemple: Fonction factorielle:\[n!=\left\{\begin{array}{ll}1 &\mbox{si }n=0\\n \cdot (n-1)! &\mbox{si }n>0$$\end{array}\right.\]\begin{center}\fcolorbox{white}{Lightgray}{\begin{codebox}\Procname{$\proc{Factorial}(n)$}\li \If $n\leq 1$\li \Then \Return 1 \End\li \Return $n \cdot \proc{Factorial}(n-1)$\end{codebox}}\end{center}\end{frame}\begin{frame}{Algorithmes récursifs}\begin{center}\fcolorbox{white}{Lightgray}{\begin{codebox}\Procname{$\proc{Factorial}(n)$}\li \If $n\leq 1$\li \Then \Return 1 \End\li \Return $n \cdot \proc{Factorial}(n-1)$\end{codebox}}\end{center}\bigskipRègles pour développer une solution récursive:\bigskip\begin{itemize}\item On doit définir un cas de base ($n\leq1$)\item On doit diminuer la ``taille'' du problème à chaque étape ($n\rightarrow n-1$)\item Quand les appels récursifs se partagent la même structure de données, les sous-problèmes ne doivent pas se superposer (pour éviter les effets de bord)\end{itemize}\end{frame}\begin{frame}{Exemple de récursion multiple}Calcul du $k$ième nombre de Fibonacci:\begin{eqnarray*}F_0&=&0\\F_1&=&1\\\forall i\geq 2: F_i& = &F_{i-2}+F_{i-1}\end{eqnarray*}Algorithme:\begin{center}\fcolorbox{white}{Lightgray}{\begin{codebox}\Procname{$\proc{Fibonacci}(n)$}\li \If $n \leq 1$\li \Then \Return n \End\li \Return $\proc{Factorial}(n-2)+\proc{Factorial}(n-1)$\end{codebox}}\end{center}% Prendre le début du cours de Carnagazi\end{frame}\begin{frame}{Exemple de récursion multiple}\begin{center}\fcolorbox{white}{Lightgray}{\begin{codebox}\Procname{$\proc{Fibonacci}(n)$}\li \If $n \leq 1$\li \Then \Return n \End\li \Return $\proc{Factorial}(n-2)+\proc{Factorial}(n-1)$\end{codebox}}\end{center}% Prendre le début du cours de Carnagazi\bigskip\begin{enumerate}\item L'algorithme est correct?\item Quelle est sa vitesse d'exécution?\item Y-a-t'il moyen de faire mieux?\end{enumerate}\end{frame}\begin{frame}{Exemple de récursion multiple}\begin{center}\fcolorbox{white}{Lightgray}{\begin{codebox}\Procname{$\proc{Fibonacci}(n)$}\li \If $n \leq 1$\li \Then \Return n \End\li \Return $\proc{Fibonacci}(n-2)+\proc{Fibonacci}(n-1)$\end{codebox}}\end{center}% Prendre le début du cours de Carnagazi\bigskip\begin{enumerate}\item L'algorithme est correct?\begin{itemize}\item Clairement, l'algorithme est correct.\item En général, la correction d'un algorithme récursif se démontre par induction.\end{itemize}\item Quelle est sa vitesse d'exécution?\item Y-a-t'il moyen de faire mieux?\end{enumerate}\note{faire la démonstration au tableau:Pour n<=1, l'algo renvoie n, ce qui est correctSi l'algorithme est correct pour tout n<n', on doit montrer qu'il est correct pour n+1. C'est évident.}\end{frame}\begin{frame}{Vitesse d'exécution}\begin{itemize}\item Nombre d'opérations pour calculer $\proc{Fibonacci}(n)$ en fonction de $n$\item Empiriquement:\end{itemize}\begin{center}\includegraphics[width=8cm]{Figures/cpu-fibonacci.pdf}\end{center}(Toutes les implémentations atteignent leur limite, plus ou moins loin)\end{frame}\begin{frame}{Trace d'exécution}\centerline{\includegraphics[width=8cm]{Figures/trace-fibonacci.pdf}}\end{frame}\begin{frame}{Complexité}\begin{center}\fcolorbox{white}{Lightgray}{\begin{codebox}\Procname{$\proc{Fibonacci}(n)$}\li \If $n \leq 1$\li \Then \Return n \End\li \Return $\proc{Fibonacci}(n-2)+\proc{Fibonacci}(n-1)$\end{codebox}}\end{center}\bigskip\begin{itemize}\item Soit $T(n)$ le nombre d'opérations de base pour calculer $\proc{Fibonacci}(n)$:\begin{eqnarray*}T(0) & = & 2, T(1)=2\\T(n) & = & T(n-1)+T(n-2)+2\\\end{eqnarray*}\item On a donc $T(n)\geq F_n$.\end{itemize}\end{frame}\begin{frame}{Complexité}\begin{itemize}\item Comment croît $F_n$ avec $n$ ?$$T(n)\geq F_n=F_{n-1}+F_{n-2}$$Puisque $F_n\geq F_{n-1}\geq F_{n-3}\geq\ldots$$$F_n\geq 2 F_{n-2}\geq 2(2 F_{n-4})\geq 2(2(2 F_{n-6})) \geq 2^{\frac{n}{2}}$$Et donc$$T(n)\geq (\sqrt{2})^n \approx (1.4)^n$$\item $T(n)$ croît \alert{exponentiellement} avec $n$\bigskip\item Peut-on faire mieux ?\end{itemize}\note{Dire que le problème vient du fait qu'on calcule plusieurs fois les mêmes choses}\end{frame}\begin{frame}{Solution itérative}\begin{center}\fcolorbox{white}{Lightgray}{\begin{codebox}\Procname{$\proc{Fibonacci-Iter}(n)$}\li \If $n \leq 1$\li \Then \Return n \End\li \Else $pprev\gets 0$\li \Then $prev\gets 1$\li \For $i\gets 2 \To n$\li \Do $f\gets prev+pprev$\li $pprev\gets prev$\li $prev\gets f$\End\li \Return f \End\end{codebox}}\end{center}%Complexité: $O(n)$\end{frame}\begin{frame}{Vitesse d'exécution}Complexité: $O(n)$\bigskip\centerline{\includegraphics[width=8cm]{Figures/cpu-fibonacci-iter.pdf}}\end{frame}\begin{frame}{Tri par fusion}Idée d'un tri basé sur la récursion:\begin{itemize}\item on sépare le tableau en deux sous-tableaux de la même taille\item on trie (récursivement) chacun des sous-tableaux\item on fusionne les deux sous-tableaux triés en maintenant l'ordre\end{itemize}Le cas de base correspond à un tableau d'un seul élément.\bigskip\begin{center}\fcolorbox{white}{Lightgray}{%    \begin{codebox}      \Procname{$\proc{merge-sort}(A,p,r)$}      \li \If $\id{p}<\id{r}$       \li \Then $q \gets \frac{p+q}{2}$      \li       $\proc{merge-sort}(A,p,q)$      \li       $\proc{merge-sort}(A,q+1,r)$      \li       $\proc{merge}(A,p,q,r)$ \End    \end{codebox}}\end{center}\centerline{Appel initial: $\proc{merge-sort}(A,1,A.length)$}\bigskipExemple d'application du principe général de ``\alert{diviser pour régner}''\note{ce principe reviendra souvent dans ce cours}\end{frame}\begin{frame}{Tri par fusion: illustration}\centerline{\includegraphics[width=6cm]{Figures/CLRS/mergesort-power2.pdf}}\note{\centerline{\includegraphics[width=6cm]{Figures/CLRS/mergesort-notpower2.pdf}}}\end{frame}\begin{frame}{Fonction $\proc{merge}$}$\proc{merge}(A,p,q)$:\begin{itemize}\item {\bf Entrée:} tableau $A$ et indice $p$, $q$, $r$ tels que:\begin{itemize}\item $p\leq q<r$ (pas de tableaux vides)\item Les sous-tableaux $A[p\twodots q]$ et $A[q+1\twodots r]$ sont ordonnés\end{itemize}\item {\bf Sortie:} Les deux sous-tableaux sont fusionnés en seul sous-tableau ordonné dans $A[p\twodots q]$\end{itemize}\bigskipIdée:\begin{itemize}\item Utiliser un pointeur vers le début de chacune des listes;\item Déterminer le plus petit des deux éléments pointés;\item Déplacer cet élément vers le tableau fusionné;\item Avancer le pointeur correspondant\end{itemize}\note{Faire l'analogie avec deux jeux de cartes triés qu'on veut rassembler. prendre un jeu de carte.}\end{frame}\begin{frame}{Fusion: algorithme}\begin{center}\small   \fcolorbox{white}{Lightgray}{    \begin{codebox}      \Procname{$\proc{Merge}(A,p,q,r)$}      \li $n_1 = q-p+1$; $n2 = r-q$      \li Soit $L[1..n_1+1]$ and $R[1..n_2+1]$ deux nouveaux tableaux      \li \For $i=1$ \To $n_1$      \li \Do $L[i]=A[p+i-1]$ \End      \li \For $j=1$ \To $n_1$      \li \Do $R[j]=A[q+j]$ \End      \li $L[n_1+1]=\infty$; $R[n_2+1]=\infty$ \RComment \textcolor{red}{Sentinels}      \li i=1;j=1      \li \For $k\gets p$ \To $r$      \li \Do \If $L[i]\leq R[j]$      \li \Then $A[k]\gets L[i]$      \li       $i\gets i+1$      \li \Else $A[k]=R[j]$      \li       $j\gets j+1$          \End     \end{codebox}}\end{center}\end{frame}\begin{frame}{Fusion: illustration}\centerline{\includegraphics[width=8cm]{Figures/mergeillustration.pdf}}\bigskipComplexité: $O(n)$ (où $n=r-p+1$)\end{frame}\begin{frame}{Vitesse d'exécution}Complexité de $\proc{merge-sort}$: $O(n\log n)$ (voir partie 2)\bigskip\centerline{\includegraphics[width=8cm]{Figures/compare-sort.pdf}}\note{Dans un prochain cours, on verra que le tri par fusion est  optimal en terme de temps de calcul (N log N)}\end{frame}\begin{frame}{Remarques}\begin{itemize}\item La fonction $\proc{merge}$ nécessite d'allouer deux tableaux $L$  et $R$ (dont la taille est $O(n)$). Exercice (difficile): écrire une  fonction $\proc{merge}$ qui ne nécessite pas d'allocation  supplémentaire.\item On pourrait réécrire $\proc{merge-sort}$ de manière itérative (au prix de la simplicité)\item Version récursive du tri par insertion:\begin{center}\fcolorbox{white}{Lightgray}{\begin{codebox}\Procname{$\proc{Insertion-Sort-rec}(A,n)$}\li \If $n>1$\li \Then $\proc{Insertion-Sort-rec}(A,n-1)$\li       $\proc{Merge}(A,1,n-1,n)$ \End\end{codebox}}\end{center}\end{itemize}\end{frame}\begin{frame}{Note sur l'implémentation de la récursivité}\begin{itemize}\item Trace d'exécution de la factorielle\centerline{\includegraphics[width=2cm]{Figures/trace-factorielle.pdf}}\item Chaque appel récursif nécessite de mémoriser le \alert{contexte d'invocation}\item L'espace mémoire utilisé est donc $O(n)$ ($n$ appels récursifs)\end{itemize}\note{!! Il est important de garder ça en mémoire: les algos récursifs ont un coût en terme d'espace mémoire}\end{frame}\begin{frame}{Récursivité terminale}\begin{itemize}\item Définition: Une procédure est \alert{récursive terminale} (tail récursive) si elle n'effectue plus aucune opération après s'être invoquée récursivement.\bigskip\item Avantages:\begin{itemize}\item Le contexte d'invocation ne doit pas être mémorisé et donc l'espace mémoire nécessaire est réduit\item Les procédures récursives terminales peuvent facilement être converties en procédures itératives\end{itemize}\end{itemize}\end{frame}\begin{frame}{Version récursive terminale de la factorielle}\begin{center}\fcolorbox{white}{Lightgray}{\begin{codebox}\Procname{$\proc{Factorial2}(n)$}\li \Return $\proc{Factorial2-rec}(n,2,1)$\end{codebox}}\end{center}\begin{center}\fcolorbox{white}{Lightgray}{\begin{codebox}\Procname{$\proc{Factorial2-rec}(n,i,f)$}\li \If $i>n$\li \Then \Return $f$\End\li \Return $\proc{Factorial2-rec}(n,i+1,f\cdot i)$\end{codebox}}\end{center}\bigskipEspace mémoire utilisé: $O(1)$ (si la récursion terminale est implémentée efficacement)\end{frame}\begin{frame}{Ce qu'on a vu}\begin{itemize}\item Définitions générales: algorithmes, structures de données, structures de données abstraites...\item Analyse d'un algorithme itératif ($\proc{Insertion-Sort}$)\item Notions de récursivité\item Analyse d'un algorithme récursif ($\proc{Fibonacci}$)\item Tri par fusion ($\proc{MergeSort}$)\end{itemize}\end{frame}