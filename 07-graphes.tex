\part{Graphes}

\begin{frame}{Plan}

\tableofcontents

\end{frame}

\section{Définitions}

\begin{frame}{Graphes}

\begin{itemize}
\item Un \alert{graphe (dirigé)}  est un couple $(V,E)$ où:
\begin{itemize}
\item $V$ est un ensemble de n\oe uds ({\it nodes}), ou sommets ({\it vertices}) et
\item $E\subseteq V\times V$ est un ensemble d'arcs, ou arêtes ({\it edges}).
\end{itemize}
\item Un graphe \alert{non dirigé} est caractérisé par une relation symmétrique entre les sommets
\begin{itemize}
\item Une arête est un ensemble $e=\{u,v\}$ de deux sommets
\item On la notera tout de même $(u,v)$ (équivalent à $(v,u)$). 
\end{itemize}

\item Applications: modélisation de:
\begin{itemize}
\item Réseaux sociaux
\item Internet
\item World wide web
\item Cartes routières
\item \ldots
\end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Exemples}
(mettre des graphes dirigés ou non)
\end{frame}

\begin{frame}{Terminologie}

Graphe non dirigé:
\begin{itemize}
\item Deux n\oe uds sont \alert{adjacents} s'ils sont liés par une même arête
\item Une arête $(v_1,v_2)$ est dite \alert{incidente} aux n\oe uds $v_1$ et $v_2$
\item Le \alert{degré} d'un n\oe ud est égal au nombre de ses arêtes incidentes
\item Le \alert{degrée d'un graphe} est le nombre maximal d'arêtes incidentes à tout sommet.
\item Un graphe est \alert{connexe} s'il existe un chemin de tout sommet à tout autre.
\end{itemize}

\end{frame}

\begin{frame}{Terminologie}

Graphe dirigé:
\begin{itemize}
\item Une arête $(v_1,v_2)$ possède l'\alert{origine} $v_1$ et la \alert{destination}
  $v_2$. Cette arête est \alert{sortante} pour $v_1$ et \alert{entrante} pour $v_2$
\item Le degré \alert{entrant} ({\it in-degree}) et le degré \alert{sortant}
  ({\it out-degree}) d'un n\oe ud $v$ sont respectivement égaux aux nombre d'arêtes entrantes et d'arêtes sortantes de $v$
\item Un graphe est \alert{acyclique} s'il n'y a aucun cycle, c'est-à-dire
  s'il n'est pas possible de suivre les arêtes du graphes à partir
  d'un sommet $x$ et de revenir à ce même sommet $x$
\end{itemize}

\end{frame}

\begin{frame}{Type de graphes}
\begin{itemize}
\item Un graphe est \alert{simple} s'il ne possède pas de boule composées d'une seule arête, c'est-à-dire tel que:
$$\forall v \in V: (v,v)\notin E$$
\item Un \alert{arbre} est un graphe acyclique connexe
\item Un \alert{multigraphe} est une généralisation des graphes pour laquelles
  il est permis de définir plus d'une arête liant un sommet à un autre

\bigskip

\item Un graphe est \alert{pondéré} si les arêtes sont annotées par des \alert{poids}
\begin{itemize}
\item Exemple: réseau entre villes avec comme poids la distance entre
  les villes, réseau internet avec comme poids la bande passante entre routeur, etc.
\end{itemize}
\end{itemize}
\end{frame}

\section{Représentation des graphes}

\begin{frame}{Représentation I: listes d'adjacences}

Un objet $G$ de type graphe est composé:
\begin{itemize}
\item d'une liste de n\oe uds $G.V=\{1,2,\ldots,|V|\}$
\item d'un tableau $G.Adj$ de $|V|$ listes tel que:
\begin{itemize}
\item Chaque sommet $u\in G.V$ est représenté par une élément du tableau $G.Adj$
\item $G.Adj[u]$ est la liste d'adjacence de $u$, c'est-à-dire la
  liste des sommets $v$ tels que $(u,v)\in E$
\end{itemize}
\end{itemize}

\bigskip

Permet de représenter des graphes dirigés ou non
\begin{itemize}
\item Si le graphe est dirigé (resp. non dirigé), la somme des longueurs des listes de $G.Adj$ est 
$|E|$ (resp. $2|E|$).
\end{itemize}

\bigskip

Permet de représenter un graphe pondéré en associant un poids à chaque
élément de liste

\end{frame}

\begin{frame}{Exemple}

Graphe non dirigé
\centerline{\includegraphics[width=8cm]{Figures/07-adjgraphundirected.pdf}}

\bigskip

Graphe dirigé
\centerline{\includegraphics[width=8cm]{Figures/07-adjgraphdirected.pdf}}

\end{frame}

\begin{frame}{Complexités}
\begin{itemize}
\item Complexité en espace: $O(|V|+|E|)$
\begin{itemize}
\item optimal
\end{itemize}
\item Accéder à un sommet: $O(1)$
\begin{itemize}
\item optimal
\end{itemize}
\item Parcourir tous les sommets: $\Theta(|V|)$
\begin{itemize}
\item optimal
\end{itemize}
\item Parcourir toutes les arêtes: $\Theta(|V|+|E|)$
\begin{itemize}
\item ok (mais pas optimal)
\end{itemize}
\item Vérifier l'existence d'une arête $(u,v)\in E$: $O(|V|)$
\begin{itemize}
\item ou encore $O(min(degree(u),degree(v)))$
\item mauvais
\end{itemize}
\end{itemize}
\note{Discuter des opérations d'insertion et de deletion de n\oe uds et d'arêtes}
\end{frame}

\begin{frame}{Réprésentation II: matrice d'adjacence}
\begin{itemize}
\item Les n\oe uds sont les entiers de 1 à $|V|$, $G.V=\{1,2,\ldots,|V|\}$
\item $G$ est décrit par une matrice $G.A$ de dimension $|V|\times |V|$ 
\item $G.A=(a_{ij})$ tel que
\[
a_{ij}=\left\{\begin{array}{ll}
1 & \mbox{si }(i,j)\in E\\
0 & \mbox{sinon}\\
\end{array}\right.
\]
\bigskip

\item Permet de représenter des graphes dirigés ou non
\begin{itemize}
\item $G.A$ est symmétrique si le graphe est non dirigé
\end{itemize}
\item Graphe pondéré: $a_{ij}$ est le poids de l'arête $(i,j)$ si elle existe, NIL (ou 0, ou $+\infty$) sinon
\end{itemize}
\end{frame}

\begin{frame}{Exemple}

Graphe non dirigé
\centerline{\includegraphics[width=8cm]{Figures/07-matgraphundirected.pdf}}

\bigskip

Graphe dirigé
\centerline{\includegraphics[width=8cm]{Figures/07-matgraphdirected.pdf}}

\end{frame}

\begin{frame}{Complexités}
\begin{itemize}
\item Complexité en espace: $O(|V|^2)$
\begin{itemize}
\item potentiellement très mauvais
\end{itemize}
\item Accéder à un sommet: $O(1)$
\begin{itemize}
\item optimal
\end{itemize}
\item Parcourir tous les sommets: $\Theta(|V|)$
\begin{itemize}
\item optimal
\end{itemize}
\item Parcourir toutes les arêtes: $\Theta(|V|^2)$
\begin{itemize}
\item potentiellement très mauvais
\end{itemize}
\item Vérifier l'existence d'une arête $(u,v)\in E$: $O(1)$
\begin{itemize}
\item optimal
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Représentations}
\begin{itemize}
\item Listes d'adjacence:
\begin{itemize}
\item Complexité en espace optimal
\item Mauvais pour des graphes \alert{dense} et des algorithmes qui ont besoin d'accéder aux arêtes
\item Préférable pour des graphes \alert{creux} ou de degré faible
\end{itemize}

\bigskip

\item Matrice d'adjacence:
\begin{itemize}
\item Complexité en espace très mauvaise
\item Bonne pour des algorithmes qui désirent accéder aléatoirement aux arêtes
\item Préférable pour des graphes \alert{denses}
\end{itemize}
\end{itemize}

\end{frame}

\section{Parcours de graphes}

\begin{frame}{Plan}

\tableofcontents[currentsection]

\end{frame}

\begin{frame}{Parcours de graphes}
\begin{itemize}
\item Objectif: parcourir tous les n\oe uds d'un graphe qui sont accessibles à partir d'un n\oe uds $v$ donné
\item Un n\oe ud $v'$ est accessible à partir de $v$ si:
\begin{itemize}
\item soit $v'=v$,
\item soit $v'$ est adjacent à $v$,
\item soit $v'$ est adjacent à un n\oe ud $v''$ qui est accessible à partir de $v$
\end{itemize}

\bigskip

\item Différents types de parcours:
\begin{itemize}
\item En profondeur d'abord ({\it depth-first})
\item En largeur d'abord ({\it breadth-first})
\end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Parcours en largeur d'abord ({\it breadth-first search})}
\begin{itemize}
\item Un des algorithmes les plus simples pour parcourir un graphe
\item A la base de plusieurs algorithmes de graphe importants%(Dijkstra, Prim...)

\bigskip

\item Entrées: un graphe $G=(V,E)$ et un sommet $s\in V$
\begin{itemize}
\item Parcourt le graphe en ``touchant'' tous les sommets qui sont accessibles à partir de $s$
\item Parcourt les sommets par ordre croissant de leur distance (en
  nombre minimum d'arêtes) par rapport à $s$
\item Calcule pour chaque sommet $v\in V$ sa distance $v.d$ à $s$
%\item Produit un arbre {\it en profondeur d'abord} ayant pour racine $s$
\item Fonctionne aussi bien pour des graphes dirigés que non dirigés
\end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Exemple}

\centerline{\includegraphics[width=9cm]{Figures/07-breadth-first-graph.pdf}}

\end{frame}

\begin{frame}{Parcours en largeur d'abord: Algorithme}

\begin{columns}
\begin{column}{6cm}
\begin{center}
{\small
\fcolorbox{white}{Lightgray}{%
      \begin{codebox}
        \Procname{$\proc{BFS}(G,s)$}
        \li \For each vertex $u \in G.V\setminus \{s\}$
        \li \Do $u.d=\infty$\End
        \li $s.d=0$
        \li $Q=\emptyset$
        \li $\proc{Enqueue}(Q,s)$
        \li \While $Q\neq \emptyset$
        \li \Do $u=\proc{Dequeue}(Q)$
        \li \For each $v\in G.Adj[u]$
        \li\Do \If $v.d=\infty$
        \li \Then $v.d=u.d+1$
        \li $\proc{Enqueue}(Q,v)$\End\End\End
        %% \Procname{$\proc{BFS}(G,s)$}
        %% \li \For each vertex $u \in G.V\setminus \{s\}$
        %% \li \Do $u.color=\const{White}$
        %% \li $u.d=\infty$
        %% \li $u.\pi=\const{NIL}$\End
        %% \li $s.color=\const{Gray}$
        %% \li $s.d=0$
        %% \li $s.\pi=\const{NIL}$
        %% \li $Q=\emptyset$
        %% \li $\proc{Enqueue}(Q,s)$
        %% \li \While $Q\neq \emptyset$
        %% \li \Do $u=\proc{Dequeue}(Q)$
        %% \li \For each $v\in G.Adj[u]$
        %% \li\Do \If $v.color\isequal \const{White}$
        %% \li \Then $v.color=\const{Gray}$
        %% \li $v.d=u.d+1$
        %% \li $v.\pi = u$
        %% \li $\proc{Enqueue}(Q,v)$\End\End
        %% \li $u.color=\const{Black}$\End
      \end{codebox}}
}
\end{center}
\end{column}
\begin{column}{5cm}
\begin{itemize}
\item $Q$ est une file (LIFO) qui contient les n\oe uds ``touchés'' mais pas encore visités
\item Le calcul de l'attribut $d$ n'est pas nécessaire (on peut le
  remplacer par un drapeau binaire)
\end{itemize}
\end{column}
\end{columns}

\end{frame}


\begin{frame}{Parcours en largeur d'abord: Complexité}

\begin{columns}
\begin{column}{6cm}
\begin{center}
{\small\vspace{-0.3cm}
\fcolorbox{white}{Lightgray}{%
      \begin{codebox}
        \Procname{$\proc{BFS}(G,s)$}
        \li \For each vertex $u \in G.V\setminus \{s\}$
        \li \Do $u.d=\infty$\End
        \li $s.d=0$
        \li $Q=\emptyset$
        \li $\proc{Enqueue}(Q,s)$
        \li \While $Q\neq \emptyset$
        \li \Do $u=\proc{Dequeue}(Q)$
        \li \For each $v\in G.Adj[u]$
        \li\Do \If $v.d=\infty$
        \li \Then $v.d=u.d+1$
        \li $\proc{Enqueue}(Q,v)$\End\End\End
        %% \Procname{$\proc{BFS}(G,s)$}
        %% \li \For each vertex $u \in G.V\setminus \{s\}$
        %% \li \Do $u.color=\const{White}$
        %% \li $u.d=\infty$
        %% \li $u.\pi=\const{NIL}$\End
        %% \li $s.color=\const{Gray}$
        %% \li $s.d=0$
        %% \li $s.\pi=\const{NIL}$
        %% \li $Q=\emptyset$
        %% \li $\proc{Enqueue}(Q,s)$
        %% \li \While $Q\neq \emptyset$
        %% \li \Do $u=\proc{Dequeue}(Q)$
        %% \li \For each $v\in G.Adj[u]$
        %% \li\Do \If $v.color\isequal \const{White}$
        %% \li \Then $v.color=\const{Gray}$
        %% \li $v.d=u.d+1$
        %% \li $v.\pi = u$
        %% \li $\proc{Enqueue}(Q,v)$\End\End
        %% \li $u.color=\const{Black}$\End
      \end{codebox}}
}
\end{center}
\end{column}
\begin{column}{5cm}
\begin{itemize}
\item Chaque sommet est enfilé au plus une fois
  ($v.d infini \rightarrow v.d$ fini)
\item Boucle $\While$ exécutée $O(|V|)$ fois
\item Boucle interne: $O(|E|)$ \alert{au total}
\item Au total: $O(|V|+|E|)$
\end{itemize}
\end{column}
\end{columns}

\end{frame}

\begin{frame}{Parcours en largeur d'abord}

\begin{itemize}
\item Correction:
\begin{itemize}
\item L'algorithme fait bien un parcours du graphe en largeur et $v.d$ contient bien la distance minimale de $s$ à $v$
\item Pas évident à montrer. On le fera plus loin pour l'algorithme de Dijkstra (calcul du plus court chemin)
\end{itemize}

\bigskip

\item Applications:
\begin{itemize}
\item Calcul des plus courtes distances d'un sommet à tous les autres
\item Recherche du plus court chemin entre deux sommets
\item Calcul du diamètre d'un arbre
\item Tester si un graphe est biparti
\item \ldots
\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}{Parcours en profondeur d'abord}

\begin{itemize}
\item Parcours du graphe en profondeur:
\begin{itemize}
\item On suit immédiatement les arêtes incidentes au dernier sommet visité
\begin{itemize}
\item Au lieu de les placer dans une file comme dans le parcours en largeur
\end{itemize}
\item On revient en arrière quand le sommet visité n'a plus de sommets adjacents non visités
\end{itemize}

\bigskip

\item Entrée: un graphe $G=(V,E)$ (pas de sommet source !)
\item Sortie: 2 ``dates'' associées à chaque sommet $v$:
\begin{itemize}
\item $v.d$=début du traitement du sommet $v$ (découverte du sommet)
\item $v.f$=fin du traitement du sommet $v$
\end{itemize}
\end{itemize}

\note{On ne voit pas un algo qui parcourt le graphe comme le
  bread-first parce que l'algo ici sera utile pour d'autres
  applications. Notamment le tri topologique}
\end{frame}

\begin{frame}{Exemple}

\centerline{\includegraphics[width=10cm]{Figures/07-dfs-exemple-onenode.pdf}}

\bigskip

Parcours en profondeur à partir de $A$: $A$-$D$-$F$-$G$-$B$-$E$ ($C$ et $H$ pas accessibles)

\end{frame}

\begin{frame}{Parcours en profondeur d'abord: implémentation}

\begin{columns}
\begin{column}{5cm}
\begin{center}
{\small\vspace{-0.3cm}
\fcolorbox{white}{Lightgray}{%
      \begin{codebox}
        \Procname{$\proc{DFS}(G,s)$}
        \li \For each vertex $u \in G.V\setminus \{s\}$
        \li \Do $u.color=\const{White}$\End
        \li $s.color=\const{Black}$        
        \li $S=\emptyset$
        \li $\proc{Push}(S,s)$
        \li \While $S\neq \emptyset$
        \li \Do $u=\proc{Pop}(S)$
        \li \For each $v\in G.Adj[u]$
        \li\Do \If $v.color=\const{White}$
        \li \Then $v.color=\const{Black}$
        \li $\proc{Push}(S,v)$\End\End\End
      \end{codebox}}
}
\end{center}
\end{column}
\begin{column}{5cm}
\begin{itemize}
\item On remplace la file $Q$ par une pile $S$
\item Chaque sommet est visité au plus une fois ($v.color$ blanc
  $\rightarrow$ noir)
\item Boucle $\While$ executées $O(|V|)$ fois
\item Boucle interne: $O(|E|)$ \alert{au total}
\item Complexité: $O(|V|+|E|)$
\end{itemize}
\end{column}
\end{columns}

\end{frame}

\begin{frame}{Parcours en profondeur d'abord: implémentation}

\begin{columns}
\begin{column}{5cm}
\begin{center}
{\small
\fcolorbox{white}{Lightgray}{%
      \begin{codebox}
        \Procname{$\proc{DFS}(G)$}
        \li \For each vertex $u \in G.V$
        \li \Do $u.color=\const{White}$\End
        \li $time=0$ \Comment global variable
        \li \For each $u\in G.V$
        \li  \Do \If $u.color\isequal \const{White}$
        \li   \Then $\proc{DFS-Visit}(G,u)$\End\End
      \end{codebox}}
}
\end{center}
\end{column}
\begin{column}{5cm}
\begin{center}
{\small
\fcolorbox{white}{Lightgray}{%
      \begin{codebox}
        \Procname{$\proc{DFS-Visit}(G,u)$}
        \li $time=time+1$
        \li $u.d=time$
        \li $u.color=\const{Gray}$
        \li \For each $v\in G.Adj[u]$
        \li \Do \If $v.color\isequal \const{White}$
        \li \Then $\proc{DFS-Visit}(G,v)$\End\End
        \li $u.color=\const{Black}$
        \li $time = time + 1$
        \li $u.f=time$
      \end{codebox}}
}
\end{center}
\end{column}
\end{columns}

\bigskip

L'attribut $color$ permet de marquer les sommets déjà découverts:
\begin{itemize}
\item $\const{White}$: sommets non découverts
\item $\const{Gray}$: sommets découverts mais pas encore traités complètement
\item $\const{Black}$: sommets traités complètement
\end{itemize}
(la couleur $\const{Gray}$ n'est pas nécessaire)

\end{frame}

\begin{frame}{Exemple}

\centerline{\includegraphics[width=10cm]{Figures/07-dfs-exemple.pdf}}

\end{frame}

\begin{frame}{Parcours en profondeur d'abord: complexité}

\begin{columns}
\begin{column}{5cm}
\begin{center}
{\small
\fcolorbox{white}{Lightgray}{%
      \begin{codebox}
        \Procname{$\proc{DFS}(G)$}
        \li \For each vertex $u \in G.V$
        \li \Do $u.color=\const{White}$\End
        \li $time=0$ \Comment global variable
        \li \For each $u\in G.V$
        \li  \Do \If $u.color\isequal \const{White}$
        \li   \Then $\proc{DFS-Visit}(G,u)$\End\End
      \end{codebox}}
}
\end{center}
\end{column}
\begin{column}{5cm}
\begin{center}
{\small
\fcolorbox{white}{Lightgray}{%
      \begin{codebox}
        \Procname{$\proc{DFS-Visit}(G,u)$}
        \li $time=time+1$
        \li $u.d=time$
        \li $u.color=\const{Gray}$
        \li \For each $v\in G.Adj[u]$
        \li \Do \If $v.color\isequal \const{White}$
        \li \Then $\proc{DFS-Visit}(G,v)$\End\End
        \li $u.color=\const{Black}$
        \li $time = time + 1$
        \li $u.f=time$
      \end{codebox}}
}
\end{center}
\end{column}
\end{columns}

\bigskip

\begin{itemize}
\item Boucle lignes 4-6 de $\proc{DFS-Visit}(G,u)$: $\Theta(out-degree(u))$
\item $\proc{DFS-Visit}(G,u)$ est appelé une seule fois pour chaque sommet
\begin{itemize}
\item On l'appelle sur un sommet blanc uniquement et on le marque gris directement après l'appel
\end{itemize}
\item Complexité globale: $\Theta(|V|+|E|)$
\end{itemize}

\note{Pourquoi $\Theta$ ? Parce que l'algorithme parcourt tout le graphe contrairement au breadth-first}

\end{frame}

\begin{frame}{Application: tri topologique}
\begin{itemize}
\item Tri topologique:
\begin{itemize}
\item Etant donné un \alert{graphe acyclique dirigé} (DAG), trouver un
  ordre des sommets tel qu'il n'y ait pas d'arête d'un n\oe ud vers un
  des n\oe uds qui le précède dans l'ordre
\item C'est toujours possible si le graphe est acyclique
\end{itemize}

\bigskip

\item Exemples d'applications:
\begin{itemize}
\item Trouver un ordre pour suivre un ensemble de cours qui tienne compte des prérequis de chaque cours
\begin{itemize}
\item Pour suivre SDA, il faut avoir suivi Introduction à la programmation
\end{itemize}
\item Résoudre les dépendances pour l'installation de logiciels
\begin{itemize}
\item Trouver un ordre d'installation de manière à ce que chaque logiciel soit installé après tous ceux dont il dépend
\end{itemize}
\end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Illustration}
Graphe

\centerline{\includegraphics[width=8cm]{Figures/07-tritopo-exemple.pdf}}

\bigskip

Une tri topologique

\centerline{\includegraphics[width=10cm]{Figures/07-tritopo-exemple-solution.pdf}}

\end{frame}

\begin{frame}{Algorithme}

Deux solutions:
\begin{itemize}
\item En utilisant le parcours en profondeur
\begin{center}
{\small
\fcolorbox{white}{Lightgray}{%
      \begin{codebox}
        \Procname{$\proc{Topological-sort}(G)$}
        \li $\proc{DFS}(G)$
        \li Return nodes in $G.V$ in reverse order of $v.f$
        \end{codebox}}
}
\end{center}
\bigskip

\item Une solution gloutonne:
\begin{itemize}
\item Rechercher un sommet qui n'a pas d'arête entrante 
\item Ajouter ce sommet à un tri topologique du graphe dont on a retiré ce sommet et toute ses arêtes
\end{itemize}

\bigskip

\item Complexité dans les deux cas: $\Theta(|E|+|V|)$
\end{itemize}

\end{frame}

\begin{frame}{Illustration}

Calcul de $v.d$ et $v.f$ sur l'exemple illustratif

\centerline{\includegraphics[width=8cm]{Figures/07-tritopo-annotated.pdf}}

Tri selon $v.f$

\centerline{\includegraphics[width=10cm]{Figures/07-tritopo-annotated-2.pdf}}

\end{frame}

\section{Plus courts chemins}

\begin{frame}{Plan}

\tableofcontents[currentsection]

\end{frame}

\begin{frame}{Plus courts chemins}

\end{frame}

\section{Arbre de couverture}

\begin{frame}{Plan}

\tableofcontents[currentsection]

\end{frame}

\begin{frame}{Arbre de courverture}
\end{frame}

