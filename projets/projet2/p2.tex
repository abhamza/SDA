\documentclass[a4paper,10pt]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{../../clrscode3epg}
\usepackage{color}
%\usepackage{fullpage}
\renewcommand{\labelenumi}{(\alph{enumi})}

% Style
\parskip=\smallskipamount

% En-têtes
\title{
    \textbf{Structures de données et algorithmes}\\
    Projet 2: tables de hachage
}

\author{Gilles \textsc{Louppe} -- Julien \textsc{Becker}}
\date{16 mars 2013}

% Corps
\begin{document}
\maketitle

L'objectif du projet est d'écrire un algorithme efficace permettant de
calculer l'intersection de deux fichiers (en terme de lignes). On
étudiera d'abord théoriquement différentes solutions et la plus
efficace sera ensuite implémentée.

Le projet est à réaliser {\bf individuellement ou par deux ?} pour le {\bf 15 avril 2013} à
{\bf 05h00} (du matin) au plus tard. Le projet est à remettre via une interface
web disponible sur \href{http://www.montefiore.ulg.ac.be/~glouppe/2012-2013/students.info0902.php}{la page des TPs}.

Un projet non rendu à temps recevra automatiquement une cote nulle. En
cas de plagiat avéré, l'étudiant se verra affecter une cote nulle à
l'ensemble du projet. Soyez bref mais précis dans votre rapport, qui
fera au maximum 5 pages, et respectez bien la numérotation des
sous-questions de l'énoncé.

Les critères de correction sont précisés sur la page web des projets.

\section{Enoncé}

On aimerait implémenter un programme permettant d'afficher les lignes
communes à deux fichiers passés en argument. Par exemple, si les
fichiers \texttt{A.txt} et \texttt{B.txt} ont les contenus suivants:
...

Le résultat de l'application du programme affichera les lignes suivantes: ...

L'ordre d'affichage des lignes communes n'a pas d'importance.

\section{Analyse théorique}

Dans cette section, on supposera que les nombres de lignes dans les fichiers sont
respectivement $N_A$ et $N_B$ et que $N_A\leq N_B$.
\begin{enumerate}
\item Quelle est la complexité théorique minimale, en fonction de $N_A$ et $N_B$, quelle que soit la
  solution adoptée ? (sans faire d'autres hypothèses sur le contenu
  des fichiers). Justifiez votre réponse.
\item Une solution générale à ce problème consiste à lire et à stocker
  dans une structure de données les lignes du premier fichier et à
  ensuite parcourir les lignes du second fichier en affichant celles qui
  se trouvent dans la structure. Donnez et justifiez la complexité au pire cas de cette solution
  lorsqu'on utilise les structures de données suivantes:
\begin{itemize}
\item liste
\item vecteur
\item arbre binaire de recherche
\item table de hachage
\end{itemize}
\item Si on pouvait supposer que les lignes des deux fichiers étaient
  triées par ordre alphabétique, comme procéderiez-vous et quelle
  serait la complexité de votre solution aux meilleur et pire cas ?
\end{enumerate}

\section{Implémentation}

On vous demande d'implémenter la solution basée sur une table de
hachage.

On leur fournirait:
\begin{itemize}
\item Deux fichiers \texttt{hashtable.h} et \texttt{hashtable.c}: qui définissent l'interface pour la table de hachage. On peut leur fournir une fonction de hachage de string.
\item Deux fichiers \texttt{intersection.h} et \texttt{intersection.c}: où on mettrait
  dans le main une fonction qui recopierait les fichiers en entrée sur
  la sortie standard et qu'il devrait modifier pour obtenir la
  fonction demandée.
\item Deux fichiers de test \texttt{A.txt} et \texttt{B.txt} assez gros.
\end{itemize}

Pour compiler le programme, vous pouvez utiliser la commande suivante:

{\small \texttt{gcc ... --std=c99 --pedantic -Wall -Wextra -Wmissing-prototypes -o intersection}}

Ce programme prend comme argument...

Contraintes: Vous pouvez choisir le système de gestion de collision
que vous voulez mais votre programme doit rester {\it efficace} quelle
que soit la longueur des fichiers d'entrée.

Appliquez la fonction pour trouver les lignes communes aux deux
fichiers \texttt{A.txt} et \texttt{B.txt} fournis.


\end{document}
