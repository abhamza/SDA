\documentclass[a4paper,10pt]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{../../clrscode3epg}
%\usepackage{fullpage}
\renewcommand{\labelenumi}{(\alph{enumi})}

% Style
\parskip=\smallskipamount

% En-têtes
\title{
    \textbf{Structures de données et algorithmes}\\
    Projet 1: Algorithmes de tri
}

\author{Julien \textsc{Becker} - Gilles \textsc{Louppe}}
\date{24 février 2012}

% Corps
\begin{document}
\maketitle

\section*{\'Enoncé}

L'objectif du projet est d'implémenter, de comparer et d'analyser empiriquement trois algorithmes de tri : le QuickSort, le HeapSort et le InsertionSort.

Le projet est à réaliser {\bf individuellement} pour le {\bf 17 mars 2012} à {\bf 05h00}. Le projet est à remettre via une interface web. Vous trouverez le lien sur la page des assistants. Un projet non rendu à temps recevra automatiquement une cote nulle.
En cas de plagiat avéré, l'étudiant se verra affecter une cote nulle à l'ensemble du projet.

\section*{Implémentation}
Les trois implémentations doivent respectées l'interface de tri décrite dans le fichier \textsc{Sort.h}. Chaque tri doit être implémenté dans un fichier qui lui est propre: QuickSort.h, HeapSort.h et InsertionSort.h.

Vous disposerez d'un générateur de données dans le fichier \textsc{Event.h}. Ces données sont de type \textsc{Event} et comprennent trois champs: une date de début, une date de fin et une valeur entière. Les expériences que vous devrez réaliser sont à faire sur ce type de données mais vos implémentations de tri doivent être complètement générique, c'est-à-dire, sans aucune référence vers les applications qui les exploitent ou les données qui y sont exploitées, en particulier, vers le type \textsc{Event}.

\subsection*{Exemple avec le BubbleSort}
Afin de vous aider à prendre rapidement en main le code mis en place, nous vous avons implémenté le BubbleSort dans le fichier \textsc{BubbleSort.c} ainsi qu'un petit programme d'essaie \textsc{main.c}.

Pour compiler le programme, vous pouvez utiliser la commande suivante: \\
gcc main.c BubbleSort.c Event.c --std=c99 --pedantic -Wall -W -Wmissing-prototypes -o test

Ce programme ne prend aucun argument.

\subsection*{Fichiers fournis}
\begin{description}
\item[\textsc{Sort.h}] interface à implémenter
\item[\textsc{Event.h}] interface du générateur de données
\item[\textsc{Event.c}] implémentation du générateur de données
\item[\textsc{BubbleSort.c}] implémentation du BubbleSort. Il respecte d'interface décrite dans \textsc{Sort.h}
\item[\textsc{main.c}] contient la fonction principale du programme
\end{description}
\subsection*{Fichiers à rendre}
Quatre fichiers sont à rendre dans une archive ``.tar.gz". Le nom de l'archive n'a pas d'importance.
\begin{description}
\item[\textsc{QuickSort.h}] implémente le QuickSort
\item[\textsc{HeapSort.h}] implémente le HeapSort
\item[\textsc{InsertionSort.h}] implémente le InsertionSort
\item[\textsc{Rapport.pdf}] contient vos réponses aux questions
\end{description}

{\em Note}: Les noms de fichiers font partie de l'énoncé. Tous fichier ne correspondant pas à ceux demandés dans l'énoncé ne sera pas pris en compte.

\subsection*{Robustesse}
Nous compilerons votre code avec un compilateur de GNU (gcc) en spécifiant au minimum les options de compilation « --std=c99 --pedantic -Wall -W -Wmissing-prototypes ». Si la compilation échoue, le projet reçoit une note de zéro.

\begin{itemize}
\item Le projet doit être réalisé dans le standard C99 (flag --std=c99);
\item Vos implémentations doivent fonctionner correctement, pas de {\em segmentation fault}, ou tout autre crash;
\item Pour vous aider à déboguer vos programmes, pensez à utiliser une débogueur tel que {\em gdb};
\item En cas d'erreur (lors d'une allocation, par exemple), le programme peut afficher un message informatif sur {\em stderr} (le flux d'erreur standard). Cet erreur altérera certainement votre algorithme mais elle ne doit en aucun cas provoquer un crash de l'application;
\item De même, vos implémentations ne doivent présenter aucun problème de mémoire (même non manifeste). En particulier, tout ce qui est alloué doit être libéré;
\item Avec des pointeurs et l’allocation de mémoire dynamique, il est très facile d’introduire des erreurs de mémoire. Pour détecter ce genre de problèmes, il y a des outils extrêmement utiles tels que {\em valgrind};
\end{itemize}

\section*{Questions}
\subsection*{1 - Temps d'exécution}
Soit $n$, le nombre de données à trier dans un tableau. Calculez empiriquement le temps d'exécution moyen et son écart-type des trois algorithmes pour différentes valeurs de $n$ (10, 100, 1.000, 10.000, 100.000 et 1.000.000). La moyenne et l'écart-type doivent être obtenus sur un ensemble de 10 expériences.
\begin{center}
\begin{tabular}{cccc}
	\hline
	n & QuickSort & HeapSort & InsertionSort \\
	\hline
	10 & moyenne $\pm$ écart-type & moyenne $\pm$ écart-type & moyenne $\pm$ écart-type\\
	100 & & &\\
	1.000 & & &\\
	10.000 & & &\\
	100.000 & & &\\
	1.000.000 & & &\\
\end{tabular}
\end{center}

{\em Note}: le temps d'exécution est une valeur peu précise qui dépend fortement des capacités de l'ordinateur mais également de l'état d'utilisation de celui-ci aux moments des expériences. Pour limiter cet effet, il vous est conseillé de réaliser toutes vos mesures de manière séquentielle sur la même machine.

\subsection*{2 - Nombre de comparaisons}
Les algorithmes peuvent également être évalué en fonction du nombre de comparaisons qu'ils effectuent entre les éléments du tableau. Dès lors, calculez empiriquement le nombre de comparaisons moyenne et son écart-type des trois algorithmes pour différentes valeurs de $n$ (10, 100, 1.000, 10.000, 100.000 et 1.000.000). La moyenne et l'écart-type doivent être obtenus sur un ensemble de 10 expériences.

\begin{center}
\begin{tabular}{cccc}
	\hline
	n & QuickSort & HeapSort & InsertionSort \\
	\hline
	10 & moyenne $\pm$ écart-type & moyenne $\pm$ écart-type & moyenne $\pm$ écart-type\\
	100 & & &\\
	1.000 & & &\\
	10.000 & & &\\
	100.000 & & &\\
	1.000.000 & & &\\
\end{tabular}
\end{center}

{\em Astuce}: Il n'est pas utile de modifier tous vos algorithmes au risque d'y introduire des erreurs. Vous devriez pouvoir facilement compter le nombre de comparaisons à partir du comparateur.

\subsection*{3 - Amélioration}
\begin{enumerate}
\item À partir des différents temps d'exécution, peut-on distinguer des cas dans lesquels il est préférable d'utiliser un algorithme plutôt qu'un autre ? Dans le cas contraire, essayez de nouvelles valeurs de $n$.
\item Comment expliquez-vous ce phénomène ?
\item Proposez un pseudo-code qui décrit un algorithme exploitant ce phénomène.
\end{enumerate}




\end{document}
