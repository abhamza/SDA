\documentclass[a4paper,10pt]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{../../clrscode3epg}
%\usepackage{fullpage}
\renewcommand{\labelenumi}{(\alph{enumi})}

% Style
\parskip=\smallskipamount

% En-têtes
\title{
    \textbf{Structures de données et algorithmes}\\
    Projet 1: Algorithmes de tri
}

\author{Julien \textsc{Becker} - Gilles \textsc{Louppe}}
\date{24 février 2012}

% Corps
\begin{document}
\maketitle

\section*{\'Enoncé}

L'objectif du projet est d'implémenter, de comparer et d'analyser empiriquement
trois algorithmes de tri : le QuickSort, le HeapSort et le InsertionSort.

Le projet est à réaliser {\bf individuellement} pour le {\bf 17 mars 2012} à
{\bf 05h00} (du matin) au plus tard. Le projet est à remettre via une interface
web. Vous trouverez le lien sur la page des assistants. Un projet non rendu à
temps recevra automatiquement une cote nulle. En cas de plagiat avéré,
l'étudiant se verra affecter une cote nulle à l'ensemble du projet.

\subsection*{Fichiers fournis}
\begin{description}
\item[\texttt{Sort.h}] interface à implémenter
\item[\texttt{Event.h}] interface du générateur de données
\item[\texttt{Event.c}] implémentation du générateur de données
\item[\texttt{BubbleSort.c}] implémentation du BubbleSort. Il respecte d'interface décrite dans \texttt{Sort.h}
\item[\texttt{LinkedList.h}] représentation d'une liste liée minimaliste
\item[\texttt{main.c}] contient la fonction principale du programme
\end{description}
\subsection*{Fichiers à rendre}
Cinq fichiers sont à rendre dans une archive \texttt{.tar.gz}. Le nom de l'archive n'a pas d'importance.
\begin{description}
\item[\texttt{QuickSort.c}] implémente la fonction \texttt{Sort} avec le QuickSort
\item[\texttt{HeapSort.c}] implémente la fonction \texttt{Sort} avec le HeapSort
\item[\texttt{InsertionSort.c}] implémente la fonction \texttt{Sort} avec le InsertionSort
\item[\texttt{LinkedListSort.c}] implémente la fonction \texttt{sortLinkedList}
\item[\texttt{Rapport.pdf}] contient vos réponses aux questions
\end{description}

{\em Note}: Les noms de fichiers font partie de l'énoncé. Tout fichier ne
correspondant pas à ceux demandés dans l'énoncé ne sera pas pris en compte.

\section{Implémentation}

Les trois implémentations doivent respecter l'interface de tri décrite dans le
fichier \texttt{Sort.h}. Chaque tri doit être implémenté dans un fichier qui lui
est propre: \texttt{QuickSort.c}, \texttt{HeapSort.c} et
\texttt{InsertionSort.c}.

Vous disposerez d'un générateur de données dans le fichier \texttt{Event.h}. Ces
données sont de type \texttt{Event} et comprennent trois champs: une date de
début, une date de fin et une valeur entière. Les expériences que vous devrez
réaliser sont à faire sur ce type de données mais vos implémentations de tri
doivent être complètement génériques, c'est-à-dire sans aucune référence vers
les applications qui les exploitent ou les données qui y sont exploitées, en
particulier, vers le type \texttt{Event}.

\subsection*{Exemple avec le BubbleSort}

Afin de vous aider à prendre rapidement en main le code mis en place, nous avons
implémenté à titre d'exemple l'algorithme BubbleSort dans le fichier
\texttt{BubbleSort.c} ainsi qu'un petit programme d'essai \texttt{main.c}.

Pour compiler le programme, vous pouvez utiliser la commande suivante:

{\small \texttt{gcc main.c BubbleSort.c Event.c --std=c99 --pedantic -Wall -W -Wmissing-prototypes -o test}}

Ce programme ne prend aucun argument.

\subsection*{Robustesse}

Nous compilerons votre code avec le compilateur GCC en spécifiant au
minimum les options de compilation \texttt{--std=c99 --pedantic -Wall -W -Wmissing-
prototypes}. Si la compilation échoue, le projet reçoit une note de zéro.

\begin{itemize}
\item Le projet doit être réalisé dans le standard C99 (flag \texttt{--std=c99});
\item Vos implémentations doivent fonctionner correctement, pas de {\em segmentation fault}, ou tout autre crash;
\item Pour vous aider à déboguer vos programmes, pensez à utiliser une débogueur tel que {\em gdb};
\item En cas d'erreur (lors d'une allocation, par exemple), le programme peut afficher un message informatif sur {\em stderr} (le flux d'erreur standard). Cet erreur altérera certainement votre algorithme mais elle ne doit en aucun cas provoquer un crash de l'application;
\item De même, vos implémentations ne doivent présenter aucun problème de mémoire (même non manifeste). En particulier, tout ce qui est alloué doit être libéré;
\item Avec des pointeurs et l’allocation de mémoire dynamique, il est très facile d’introduire des erreurs de mémoire. Pour détecter ce genre de problèmes, il y a des outils extrêmement utiles tels que {\em valgrind};
\end{itemize}

\section{Analyse}

Dans le cadre de ce travail, nous vous demandons également d'analyser
expérimentalement les algorithmes que vous aurez implémentés en répondant aux
questions suivantes. Vos réponses doivent être rédigées dans un bref rapport (au
format PDF) à joindre avec vos fichiers sources.

\subsection{Temps d'exécution}

Soit $n$ le nombre de données à trier dans un tableau. Calculez empiriquement le
temps d'exécution moyen et son écart-type des trois algorithmes pour différentes
valeurs de $n$ (10, 100, 1.000, 10.000, 100.000 et 1.000.000). La moyenne et l
'écart-type doivent être obtenus sur un ensemble de 10 expériences. Commentez.

\begin{center}
\begin{tabular}{cccc}
	\hline
	n & QuickSort & HeapSort & InsertionSort \\
	\hline
	10 & moyenne $\pm$ écart-type & moyenne $\pm$ écart-type & moyenne $\pm$ écart-type\\
	100 & & &\\
	1.000 & & &\\
	10.000 & & &\\
	100.000 & & &\\
	1.000.000 & & &\\
\end{tabular}
\end{center}

{\em Note}: le temps d'exécution est une valeur peu précise qui dépend fortement
des capacités de l'ordinateur mais également de l'état d'utilisation de celui-
ci au moment des expériences. Pour limiter cet effet, il vous est conseillé
de réaliser toutes vos mesures de manière séquentielle sur la même machine.

\subsection{Nombre de comparaisons}

Les algorithmes peuvent également être évalués en fonction du nombre de
comparaisons qu'ils effectuent entre les éléments du tableau. Dès lors, calculez
empiriquement le nombre de comparaisons moyenne et son écart-type des trois
algorithmes pour différentes valeurs de $n$ (10, 100, 1.000, 10.000, 100.000 et
1.000.000). La moyenne et l'écart-type doivent être obtenus sur un ensemble de
10 expériences. Commentez.

\begin{center}
\begin{tabular}{cccc}
	\hline
	n & QuickSort & HeapSort & InsertionSort \\
	\hline
	10 & moyenne $\pm$ écart-type & moyenne $\pm$ écart-type & moyenne $\pm$ écart-type\\
	100 & & &\\
	1.000 & & &\\
	10.000 & & &\\
	100.000 & & &\\
	1.000.000 & & &\\
\end{tabular}
\end{center}

{\em Astuce}: Il n'est pas utile de modifier tous vos algorithmes au risque d'y
introduire des erreurs. Vous devriez pouvoir facilement compter le nombre de
comparaisons à partir du comparateur.

\section{Liste liée}

Supposons à présent que la structure de données que nous désirons trier soit une
liste liée, telle que décrite dans le fichier \texttt{LinkedList.h}, et non plus
un tableau. Il vous est demandé d'implémenter un algorithme (de votre choix)
permettant de trier une liste liée, avec pour contrainte de ne pas utiliser une
quantité de mémoire supérieure à $O(1)$. La fonction est à implémenter dans le
fichier \texttt{LinkedListSort.c} dont le prototype \texttt{sortLinkedList} est
déclaré dans le fichier \texttt{Sort.h}.

\textit{Bonus}:  Des points supplémentaires seront attribués aux algorithmes les plus
performants en terme de temps d'exécution.

\end{document}
