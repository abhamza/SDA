\documentclass[a4paper,10pt]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{../../clrscode3epg}
%\usepackage{fullpage}
\renewcommand{\labelenumi}{(\alph{enumi})}

% Style
\parskip=\smallskipamount

% En-têtes
\title{
    \textbf{Structures de données et algorithmes}\\
    Projet 2: Arbre binaire de recherche
}

\author{Julien \textsc{Becker} - Gilles \textsc{Louppe}}
\date{16 mars 2012}

% Corps
\begin{document}
\maketitle

\section*{\'Enoncé}

L'objectif du projet est d'implémenter une structure d'arbre binaire de
recherche. Nous vous demandons de remettre le code source correspondant à votre
implémentation ainsi qu'un bref rapport répondant aux questions ci-dessous.

Le projet est à réaliser {\bf individuellement} pour le {\bf 21 avril 2012} à
{\bf 05h00} (du matin) au plus tard. Le projet est à remettre via une interface
web disponible sur \href{http://www.montefiore.ulg.ac.be/~glouppe/2011-2012/students.info0902.php}{la page des TPs}.

Un projet non rendu à temps recevra automatiquement une cote nulle. En cas de
plagiat avéré, l'étudiant se verra affecter une cote nulle à l'ensemble du
projet. Les mêmes critères de correction que ceux utilisés dans le cadre du
cours \href{http://www.montefiore.ulg.ac.be/~info0030/}{INFO0030 - Projet de programmation}
seront utilisés pour évaluer l'implémentation des algorithmes.

\subsection*{Fichier fourni}
\begin{description}
\item[\texttt{BinarySearchTree.h}] contient l'interface à implémenter
\end{description}
\subsection*{Fichiers à rendre}
Deux fichiers sont à rendre dans une archive \texttt{.tar.gz}. Le nom de l'archive n'a pas d'importance.
\begin{description}
\item[\texttt{BinarySearchTree.c}] implémente les fonctions de l'interface \texttt{BinarySeachTree.h}
\item[\texttt{Rapport.pdf}] contient vos réponses aux questions
\end{description}

{\em Note}: Les noms de fichiers font partie de l'énoncé. Tout fichier ne
correspondant pas à ceux demandés dans l'énoncé ne sera pas pris en compte.

\section{Implémentation}

La structure à implémenter est un dictionnaire permettant de stocker des paires
clé-valeur. Ce dictionnaire doit être implémenté à partir d'un arbre binaire de
recherche (simple) dont l'interface est décrite dans le fichier
\texttt{BinarySeachTree.h}. Une structure de donnée opaque
\texttt{BinarySearchTree} ainsi que neuf méthodes réalisant diverses fonctions
sur cette structure y sont définies.

Nous vous demandons d'implémenter les opérations de base suivantes:
\begin{description}
\item[\texttt{createEmptyBinarySearchTree}] qui crée un nouvel arbre de recherche binaire vide.
\item[\texttt{freeBinarySearchTree}]  qui libère la mémoire allouée par la structure de l'arbre.
\item[\texttt{getNumElements}] qui retourne le nombre d'éléments dans l'arbre.
\item[\texttt{insertElement}] qui permet d'ajouter une nouvelle paire clé-valeur dans l'arbre. Si la clé existe déjà, sa valeur est remplacée par la nouvelle.
\item[\texttt{findElement}] qui retourne la valeur associée à une clé de l'arbre.
\item[\texttt{removeElement}] qui supprime une paire clé-valeur de l'arbre.
\end{description}
La définition du contenu de la structure \texttt{BinarySearchTree\_t}
est libre d'implémentation. Les fonctions de modification de la
structure ne doivent pas nécessairement maintenir l'arbre
équilibré. Pour la suppression, on vous demande d'implémenter une
version différente de celle du cours qui utilise le prédécesseur
plutôt que le successeur pour faire le remplacement du n\oe ud
supprimé.

De plus, nous vous demandons d'implémenter de manière {\em efficace} les trois fonctions suivantes:
\begin{description}
\item[\texttt{createBinarySearchTree}] qui, sur base de tableaux
  de clés et de valeurs, construit un arbre binaire de recherche
  équilibré. %% \textit{Remarque:} seul l'état initial de l'arbre, après
  %% l'insertion initiale des paires clé-valeur, doit correspondre à un
  %% arbre équilibré. Tout appel postérieur des autres methodes peut
  %% conduire à un déséquilibre de l'arbre.
\item[\texttt{getRankOf}] qui retourne le rang d'une clé dans l'arbre,
  c'est-à-dire sa position si les clés de l'arbre étaient triées par
  ordre croissant dans un tableau.
\item[\texttt{getElementsInRange}] qui retourne un tableau de valeurs
  dont les clés sont comprises dans un intervalle. Les valeurs doivent
  être triées dans l'ordre croissant de leur clé.
\end{description}
Vous pouvez ajouter des champs supplémentaires à la structure d'arbre
de manière à améliorer l'efficacité de ces fonctions pour autant que
vous modifiiez les fonctions d'insertion et de suppression en
conséquence et que cela n'affecte pas la complexité en temps de ces
fonctions et la complexité en espace de la structure d'arbre.

\subsection*{Robustesse}

Nous compilerons votre code avec le compilateur GCC en spécifiant au
minimum les options de compilation \texttt{--std=c99 --pedantic -Wall -W -Wmissing-
prototypes}. Si la compilation échoue, le projet reçoit une note de zéro.

\begin{itemize}
\item Le projet doit être réalisé dans le standard C99 (flag
  \texttt{--std=c99});
\item Vos implémentations doivent fonctionner correctement, pas de
  {\em segmentation fault}, ou tout autre crash;
\item Pour vous aider à déboguer vos programmes, pensez à utiliser une
  débogueur tel que {\em gdb};
\item En cas d'erreur (lors d'une allocation, par exemple), le
  programme peut afficher un message informatif sur {\em stderr} (le
  flux d'erreur standard). Cet erreur altérera certainement votre
  algorithme mais elle ne doit en aucun cas provoquer un crash de
  l'application;
\item De même, vos implémentations ne doivent présenter aucun problème
  de mémoire (même non manifeste). En particulier, tout ce qui est
  alloué doit être libéré;
\item Avec des pointeurs et l’allocation de mémoire dynamique, il est
  très facile d’introduire des erreurs de mémoire. Pour détecter ce
  genre de problèmes, il y a des outils extrêmement utiles tels que
  {\em valgrind};
\end{itemize}

\section{Questions}

Pour les trois fonctions \texttt{createBinarySearchTree},
\texttt{getRankOf} et \texttt{getElementsInRange} nous vous demandons
d'expliquer les algorithmes que vous aurez implémentés et d'analyser
le temps d'exécution théorique dans le meilleur des cas et dans le
pire des cas. Pour les fonctions \texttt{getRankOf} et
\texttt{getElementsInRange}, faites l'analyse dans le cas où l'arbre
est équilibré et dans le cas où il ne le serait pas
nécessairement. Dans le cas de la fonction \texttt{getElementsInRange}
formuler ces complexités en fonction du nombre de clés dans
l'intervalle (noté $r$) et du nombre total de clés dans l'arbre (noté
$n$).

Vos réponses doivent être rédigées dans un bref rapport (au format
PDF) à joindre avec vos fichiers sources.

\end{document}
