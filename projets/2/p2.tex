\documentclass[a4paper,10pt]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{../../clrscode3epg}
%\usepackage{fullpage}
\renewcommand{\labelenumi}{(\alph{enumi})}

% Style
\parskip=\smallskipamount

% En-têtes
\title{
    \textbf{Structures de données et algorithmes}\\
    Projet 2: Arbre binaire de recherche
}

\author{Julien \textsc{Becker} - Gilles \textsc{Louppe}}
\date{16 mars 2012}

% Corps
\begin{document}
\maketitle

\section*{\'Enoncé}

L'objectif du projet est d'implémenter les arbres binaires de recherche. Nous vous demandons de remettre le code source correspondant à votre implémentation ainsi qu'un bref rapport répondant aux questions ci-dessous.

Le projet est à réaliser {\bf individuellement} pour le {\bf 21 avril 2012} à
{\bf 05h00} (du matin) au plus tard. Le projet est à remettre via une interface
web disponible sur \href{http://www.montefiore.ulg.ac.be/~glouppe/2011-2012/students.info0902.php}{la page des TPs}.

Un projet non rendu à temps recevra automatiquement une cote nulle. En cas de
plagiat avéré, l'étudiant se verra affecter une cote nulle à l'ensemble du
projet. Les mêmes critères de correction que ceux utilisés dans le cadre du
cours \href{http://www.montefiore.ulg.ac.be/~info0030/}{INFO0030 - Projet de programmation}
seront utilisés pour évaluer l'implémentation des algorithmes.

\subsection*{Fichier fourni}
\begin{description}
\item[\texttt{BinarySearchTree.h}] contient l'interface à implémenter.
\end{description}
\subsection*{Fichiers à rendre}
Deux fichiers sont à rendre dans une archive \texttt{.tar.gz}. Le nom de l'archive n'a pas d'importance.
\begin{description}
\item[\texttt{BinarySearchTree.c}] implémente les fonctions de l'interface \texttt{BinarySeachTree.h}
\item[\texttt{Rapport.pdf}] contient vos réponses aux questions
\end{description}

{\em Note}: Les noms de fichiers font partie de l'énoncé. Tout fichier ne
correspondant pas à ceux demandés dans l'énoncé ne sera pas pris en compte.

\section{Implémentation}
L'interface de l'arbre binaire de recherche décrite dans \texttt{BinarySeachTree.h} comprend une structure de donnée et neuf fonctions. La structure d'arbre de recherche proposée stocke des paires clé-valeur, c'est-à-dire que chaque clé sera associée à une valeur (de type générique). De même, chaque clé au sein d'un même arbre est unique.

Nous vous demandons d'implémenter les opérations de base suivantes:
\begin{description}
\item[\texttt{createEmptyBinarySearchTree}] qui crée un nouvelle arbre de recherche binaire.
\item[\texttt{freeBinarySearchTree}]  qui libère la mémoire allouée à la structure de arbre.
\item[\texttt{getNumElements}] qui retourne le nombre d'éléments dans l'arbre.
\item[\texttt{insertElement}] qui permet d'ajouter une nouvelle paire clé-valeur dans l'arbre. Si la clé existe déjà, sa valeur est remplacée par la nouvelle.
\item[\texttt{removeElement}] qui, sur base de la clé, permet de retirer la paire clé-valeur de l'arbre.
\item[\texttt{findElement}] qui retourne la valeur associée à une clé de l'arbre.
\end{description}

De plus, nous vous demandons d'implémenter de manière {\em efficace} les trois fonctions suivantes:
\begin{description}
\item[\texttt{createBinarySearchTree}] qui, sur base sur d'un tableau de paires clé-valeur, construit un arbre binaire de recherche {\em équilibré}.
\item[\texttt{getRankOf}] qui retourne le rang d'une clé dans l'arbre, c'est-à-dire sa position si les clés de l'arbre étaient triées par ordre croissant dans un tableau.
\item[\texttt{getElementsInRange}] qui retourne un tableau de valeurs dont les clés sont comprises dans un intervalle. Les valeurs doivent être triées dans l'ordre croissant de leur clé.
\end{description}
Votre implémentation doit être réalisée dans le fichier \texttt{BinarySeachTree.c}.

Pour les trois fonctions \texttt{createBinarySearchTree}, \texttt{getRankOf} et \texttt{getElementsInRange} nous vous demandons d'expliquer les algorithmes que vous aurez implémentés et d'analyser le temps d'exécution théorique dans le meilleur des cas, le pire des cas et le cas moyen. Vos réponses doivent être rédigées dans un bref rapport (au format PDF) à joindre avec vos fichiers sources.

\subsection*{Robustesse}

Nous compilerons votre code avec le compilateur GCC en spécifiant au
minimum les options de compilation \texttt{--std=c99 --pedantic -Wall -W -Wmissing-
prototypes}. Si la compilation échoue, le projet reçoit une note de zéro.

\begin{itemize}
\item Le projet doit être réalisé dans le standard C99 (flag \texttt{--std=c99});
\item Vos implémentations doivent fonctionner correctement, pas de {\em segmentation fault}, ou tout autre crash;
\item Pour vous aider à déboguer vos programmes, pensez à utiliser une débogueur tel que {\em gdb};
\item En cas d'erreur (lors d'une allocation, par exemple), le programme peut afficher un message informatif sur {\em stderr} (le flux d'erreur standard). Cet erreur altérera certainement votre algorithme mais elle ne doit en aucun cas provoquer un crash de l'application;
\item De même, vos implémentations ne doivent présenter aucun problème de mémoire (même non manifeste). En particulier, tout ce qui est alloué doit être libéré;
\item Avec des pointeurs et l’allocation de mémoire dynamique, il est très facile d’introduire des erreurs de mémoire. Pour détecter ce genre de problèmes, il y a des outils extrêmement utiles tels que {\em valgrind};
\end{itemize}

\end{document}
