
\part{Dictionnaires}

% Superbe site web avec les differents algorithmes

% http://www.sorting-algorithms.com/


% Plan

% recherche séquentielle
% recherche binaire (dichotomique) -> problème insertion reste lente
% binary search trees -> insertion et recherche rapide mais seulement en moyenne
% RB trees -> insertion et recherche rapide dans le pire cas
% table à accès direct: tout en $O(1)$ mais prend beaucoup de mémoire
% table hash: tout en ordre $O(1)$ mais structure non dynamique

\begin{frame}{Plan}

\tableofcontents

\end{frame}


\section{Introduction}

\begin{frame}{Dictionnaires}
\begin{itemize}
\item Définition: un \alert{dictionnaire} est un ensemble dynamique
  d'objets avec des clés comparables qui supportent les opérations
  suivantes:
\begin{itemize}
\item $\proc{Search}(S,k)$ retourne un pointeur $x$ vers un élément dans $S$ tel que $\attrib{x}{key}=k$, ou $\const{NIL}$ si un tel élément n'appartient pas à $S$.
\item $\proc{Insert}(S,x)$ insère l'élément $x$ dans le dictionnaire $S$.
\item $\proc{Delete}(S,x)$ retire l'élément $x$ de $S$.
\end{itemize}
\item Pour faciliter la recherche, on peut supposer qu'il existe un ordre total sur les clés.
\item Deux objectifs en général:
\begin{itemize}
\item minimiser le coût pour l'insertion et l'accès au données
\item minimiser l'espace mémoire pour le stockage des données
\end{itemize}
\item Exemples d'applications:
\begin{itemize}
\item Table de symboles dans un compilateur
\item Table de routage d'un DNS
\item \ldots
\end{itemize}
\item Beaucoup d'implémentations possibles
\end{itemize}
\note{Ici:
\begin{itemize}
\item Pas d'ordre sur les clés (du moins, on ne l'exploite pas)
\begin{itemize}
\item tableau à accès direct
\item table de hachage
\end{itemize}
\item Ordre sur les clés
\begin{itemize}
\item tableau trié
\item arbre binaire de recherche
\end{itemize}
}
\end{frame}

\section{Arbres binaires de recherche}

\begin{frame}{Liste liée}
Première solution:
\begin{itemize}
\item On stocke les paires clé-valeur dans une liste liée
\item Recherche et suppression par les fonctions $\proc{List-Search}$ et $\proc{List-Delete}$\\
\item Insertion:
\begin{itemize}
\item On recherche la clé dans la liste ($\proc{List-Search}$)
\item Si elle existe, on remplace la valeur
\item Si elle n'existe pas, on la place en début de liste ($\proc{List-Insert}$)
\end{itemize}
\item Complexité:
% remplacer ça par une table
\begin{itemize}
\item Insertion: $O(N)$
\item Recherche: $O(N)$
\item Suppression: $O(N)$
\end{itemize}
\item Peut-on améliorer la recherche ?
\end{itemize}
\end{frame}

\begin{frame}{Vecteur trié}

Deuxième solution:
\begin{itemize}
\item On suppose qu'il existe un ordre total sur les clés
\item On stocke les éléments dans un \alert{vecteur} qu'on maintient trié
\item Recherche dichotomique (approche ``diviser-pour-régner'')

\begin{center}
\begin{small}
\fcolorbox{white}{Lightgray}{%
  \begin{codebox}
    \Procname{$\proc{Binary-Search}(V,k,low,high)$}
    \li \If $low>high$
    \li \Then \Return \const{NIL} \End
    \li $mid\gets \lfloor (low+high)/2\rfloor$
    \li $x\gets \proc{Elem-At-Rank}(V,mid)$
    \li \If $k\isequal x.key$
    \li \Then \Return $x$
    \li \ElseIf $k>x.key$
    \li \Then \Return $\proc{Binary-Search}(V,k,mid+1,high)$
    \li \Else \Return $\proc{Binary-Search}(V,k,low,mid-1)$
    \End
\end{codebox}}
\end{small}
\end{center}
Complexité: $O(\log n)$
\end{itemize}

\end{frame}

\begin{frame}{Vecteur trié}
\begin{itemize}
\item Insertion: recherche de la position par $\proc{Binary-Search}$ puis insertion dans le vecteur par $\proc{Insert-At-Rank}$ (=décalage des éléments vers la droite).
\item Suppression: recherche puis suppression par $\proc{Remove-At-Rank}$ (=décalage des éléments vers la gauche).
\item Complexité:
\begin{itemize}
\item Insertion: $O(N)$ (on doit décaler les éléments à droite de la clé)
\item Recherche: $O(\log N)$ (recherche dichotomique)
\item Suppression: $O(N)$ (on doit décaler les éléments à gauche de la clé)
\end{itemize}

\bigskip

\item Peut-on obtenir à la fois une insertion et une recherche
  efficace?\\$\Rightarrow$ Oui, en utilisant un arbre binaire de recherche
\end{itemize}

\end{frame}

\begin{frame}{Arbre binaire de recherche}
\begin{columns}
\begin{column}{7.5cm}
\begin{itemize}
\item Implémentation:
\begin{itemize}
\item $T$ représente l'arbre, qui consiste en un ensemble de n\oe uds
\item $T.root$ est le n\oe ud racine de l'arbre $T$
\end{itemize}
\item N\oe ud $x$
\begin{itemize}
\item $\attrib{x}{parent}$ est le parent du n\oe ud $x$
\item $\attrib{x}{key}$ est la clé stockée au n\oe ud $x$
\item $\attrib{x}{left}$ est le fils de  gauche du n\oe ud $x$
\item $\attrib{x}{right}$ est le fils de droite du n\oe ud $x$
\end{itemize}
\end{itemize}
\end{column}
\begin{column}{4cm}
\begin{center}
\includegraphics[width=3cm]{Figures/05-bstnode.pdf}
\end{center}
\end{column}
\end{columns}

\bigskip

(Généralise la notion de liste liée)

\end{frame}

\begin{frame}{Arbres binaires de recherche}

\centerline{\includegraphics[width=9cm]{Figures/05-arbresbinaires.pdf}}

\begin{itemize}
\item Propriété d'arbre binaire de recherche
\begin{itemize}
\item Soient deux n\oe uds $x$ et $y$.
\item Si $y$ est dans le sous-arbre de gauche de $x$, alors $y.key\leq x.key$
\item Si $y$ est dans le sous-arbre de droite de $x$, alors $y.key\leq x.key$
\end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Parcours infixe}

\begin{center}
\includegraphics[width=5cm]{Figures/05-onebst.pdf}
\bigskip

$\Rightarrow \langle 2, 5, 5, 6, 7, 8\rangle$
\end{center}

\begin{itemize}
\item Parcours infixe: parcours en ordre des clés de l'arbre

\bigskip
\begin{center}
\begin{small}
\fcolorbox{white}{Lightgray}{%
  \begin{codebox}
    \Procname{$\proc{Inorder-Tree-Walk}(x)$}
    \li \If $x\neq \const{NIL}$
    \li \Then $\proc{Inorder-Tree-Walk}(\attrib{x}{left})$
    \li print $\attrib{x}{key}$
    \li $\proc{Inorder-Tree-Walk}(\attrib{x}{right})$
    \End
\end{codebox}}
\end{small}
\end{center}

\end{itemize}

\end{frame}

\begin{frame}{Parcours préfixe}

\begin{center}
\includegraphics[width=6cm]{Figures/05-onebst.pdf}
\bigskip

$\Rightarrow \langle 6, 5, 2, 5, 7, 8\rangle$
\end{center}

\begin{itemize}
\item Parcours préfixe (préordre): chaque n\oe ud est visité \alert{avant} ses fils

\bigskip
\begin{center}
\begin{small}
\fcolorbox{white}{Lightgray}{%
  \begin{codebox}
    \Procname{$\proc{Preorder-Tree-Walk}(x)$}
    \li \If $x\neq \const{NIL}$
    \li \Then print $\attrib{x}{key}$
    \li $\proc{Preorder-Tree-Walk}(\attrib{x}{left})$
    \li $\proc{Preorder-Tree-Walk}(\attrib{x}{right})$
    \End
\end{codebox}}
\end{small}
\end{center}

\end{itemize}

\end{frame}

\begin{frame}{Parcours postfixe}

\begin{center}
\includegraphics[width=6cm]{Figures/05-onebst.pdf}
\bigskip

$\Rightarrow \langle 2, 5, 5, 8, 7, 6\rangle$
\end{center}

\begin{itemize}
\item Parcours postfixe (postordre): chaque n\oe ud est visité \alert{après} ses fils

\bigskip
\begin{center}
\begin{small}
\fcolorbox{white}{Lightgray}{%
  \begin{codebox}
    \Procname{$\proc{Postorder-Tree-Walk}(x)$}
    \li \If $x\neq \const{NIL}$
    \li \Then $\proc{Postorder-Tree-Walk}(\attrib{x}{left})$
    \li $\proc{Postorder-Tree-Walk}(\attrib{x}{right})$
    \li print $\attrib{x}{key}$
    \End
\end{codebox}}
\end{small}
\end{center}

\end{itemize}

\end{frame}

\begin{frame}{Complexité des parcours}
\begin{itemize}
\item Tous les parcours sont $\Theta(n)$ en temps
\begin{itemize}
\item Soit $T(n)$ le nombre d'opérations pour un arbre avec $n$ n\oe uds
\item On a $T(n)=\Omega(n)$ (on doit au moins parcourir chaque n\oe ud).
\item Etant donné la récurrence, on a:
$$T(n)=T(n_l)+T(n-n_L-1) + \Theta(1)$$
\item On peut prouver par induction que $T(n)=O(n)$
\item $T(n)=\Omega(n)$ et $T(n)=O(n)$ $\Rightarrow$ $T(n)=\Theta(n)$
\end{itemize}
\item Etant donné que la sortie est de longueur $n$, on ne pourra pas faire mieux
\end{itemize}

\end{frame}

\begin{frame}{Parcours en largeur}



\begin{itemize}
\item Parcours en largeur: on visite le n\oe ud le plus proche de la racine qui n'a pas déjà été visité. Correspond à une visite de n\oe ud de profondeur 1, puis 2, \ldots.
\item Implémentation à l'aide d'une file
\end{itemize}

%\bigskip

\begin{columns}
\begin{column}{5cm}
\begin{center}
\includegraphics[width=6cm]{Figures/05-onebst.pdf}
\bigskip

$\Rightarrow \langle 6,5,7,2,5,8\rangle$
\end{center}
\end{column}~~~~~~~
\begin{column}{5cm}
\begin{center}
\begin{footnotesize}
\fcolorbox{white}{Lightgray}{%
  \begin{codebox}
    \Procname{$\proc{Breadth-Tree-Walk}(x)$}
    \li $Q\gets$''Empty queue''
    \li $\proc{Enqueue}(Q,x)$
    \li \While \textbf{not} $\proc{Queue-Empty}(Q)$
    \li \Do $y\gets\proc{Dequeue}(Q)$
    \li print $y.key$
    \li \If $y.left\neq \const{NIL}$
    \li \Then  $\proc{Enqueue}(Q,y.left)$ \End
    \li \If $y.right\neq \const{NIL}$
    \li \Then  $\proc{Enqueue}(Q,y.right)$ \End
    \End
\end{codebox}}
\end{footnotesize}
\end{center}
\end{column}
\end{columns}

\medskip

\emph{(Exercice: Implémenter le parcours en ordre de manière non récursive)}
\note{Solution: il faut utiliser une pile mais une solution simple peut être trouvée avec une comparaison de pointeurs (voir les solutions du bouquin)
}
\end{frame}

\begin{frame}{Recherche dans un arbre binaire}
\begin{itemize}
\item Recherche binaire
\begin{center}
\begin{small}
\fcolorbox{white}{Lightgray}{%
  \begin{codebox}
    \Procname{$\proc{Tree-Search}(x,k)$}
    \li \If $x\isequal \const{NIL}$ or $k\isequal \attrib{x}{key}$
    \li \Then \Return $x$\End
    \li \If $k<\attrib{x}{key}$
    \li \Then \Return $\proc{Tree-Search}(\attrib{x}{left},k)$
    \li \Else \Return $\proc{Tree-Search}(\attrib{x}{right},k)$
\end{codebox}}

\medskip

Appel initial (à partir d'un arbre $T$)\\
\fcolorbox{white}{Lightgray}{%
$\proc{Tree-Search}(\attrib{T}{root},k)$
}
\end{small}
\end{center}

\bigskip

\item Complexité ? $T(n)=O(h)$, où $h$ est la hauteur de l'arbre
\item Pire cas: $h=n$
\end{itemize}

\end{frame}

\begin{frame}{Recherche dans un arbre binaire}
\begin{itemize}
\item $\proc{Tree-Search}$ est récursive terminale.
\item Version itérative
\begin{center}
\begin{small}
\fcolorbox{white}{Lightgray}{%
  \begin{codebox}
    \Procname{$\proc{Iterative-Tree-Search}(T,k)$}
    \li $x\gets \attrib{T}{root}$
    \li \While $x\neq \const{NIL}$ and $k\neq \attrib{x}{key}$
    \li \Do \If $k<\attrib{x}{key}$
    \li \Then $x\gets \attrib{x}{left}$
    \li \Else $x\gets \attrib{x}{right}$
    \End\End
    \li \Return x
\end{codebox}}
\end{small}
\end{center}

\bigskip

\end{itemize}

\end{frame}

\begin{frame}{Clés maximale et minimale}
\begin{itemize}
\item Etant donné la propriété d'arbre binaire
\begin{itemize}
\item La clé minimale se trouve dans le n\oe ud le plus à gauche
\item La clé maximale se trouve dans le no\oe ud le plus à droite
\end{itemize}

\bigskip

\begin{center}
\fcolorbox{white}{Lightgray}{%
\begin{codebox}
          \Procname{$\proc{Tree-Minimum}(x)$}
          \li \While $\attrib{x}{left}\ne\const{NIL}$
          \li \Do $x\gets\attrib{x}{left}$
              \End
          \li \Return $x$
        \end{codebox}}~~~~~\fcolorbox{white}{Lightgray}{%
\begin{codebox}
          \Procname{$\proc{Tree-Maximum}(x)$}
          \li \While $\attrib{x}{right}\ne\const{NIL}$
          \li \Do $x\gets\attrib{x}{right}$
              \End
          \li \Return $x$
        \end{codebox}}
\end{center}

\bigskip

\item Complexité: $O(h)$, où $h$ est la hauteur de l'arbre.
\end{itemize}
\end{frame}

\begin{frame}{Successeur et prédécesseur}
\begin{itemize}
\item Etant donné un n\oe ud $x$, trouver le n\oe ud contenant la valeur de clé suivante (dans l'ordre)

\begin{center}
\includegraphics[width=7cm]{Figures/05-treesuccessor.pdf}

\bigskip

Ex: successeur de 15 $\rightarrow 17$, successeur de 4 $\rightarrow 6$.
\end{center}


\item Le successeur de $x$ est le minimum du sous-arbre de droite s'il existe
\item Sinon, c'est le premier ancêtre $a$ de $x$ tel que $x$ tombe dans le sous-arbre de gauche de $a$.
\end{itemize}
\end{frame}

\begin{frame}{Successeur et prédécesseur}

\begin{columns}
\begin{column}{5cm}
\begin{center}
\begin{small}
\fcolorbox{white}{Lightgray}{
\begin{codebox}
      \Procname{$\proc{Tree-Successor}(x)$}
      \li \If $\attrib{x}{right}\ne\const{NIL}$
      \li \Return $\proc{Tree-Minimum}(\attrib{x}{right})$
      \li $y\gets\attrib{x}{parent}$
      \li \While $y\ne\const{NIL}$ and $x\isequal\attrib{x}{right}$
      \li \Do $x\gets y$
      \li     $y\gets\attrib{y}{parent}$
      \End
      \li \Return $y$
    \end{codebox}}
\end{small}
\end{center}
\end{column}
\begin{column}{5cm}
\begin{center}

  \bigskip

\bigskip

\includegraphics[width=5cm]{Figures/05-treesuccessor.pdf}
\end{center}
\end{column}
\end{columns}

\bigskip

Complexité: $O(h)$, où $h$ est la hauteur de l'arbre

\bigskip

\emph{(Exercice: $\proc{Tree-Predecessor}$)}

\note{Attention, algo assez tordu}

\end{frame}

\begin{frame}{Insertion}

\begin{center}
\includegraphics[width=8cm]{Figures/05-bstinsertion.pdf}
\end{center}

\begin{itemize}
\item Pour insérer $x$, on recherche la clé $\attrib{x}{key}$ dans l'arbre
\item Si on ne la trouve pas, on l'ajoute à l'endroit où la recherche s'est arrêtée.
\end{itemize}
\end{frame}

\begin{frame}{Insertion}

  \begin{columns}
    \begin{column}{5cm}
\begin{center}
\begin{small}
\fcolorbox{white}{Lightgray}{
      \begin{codebox}
        \Procname{$\proc{Tree-Insert}(T, z)$}
      \li $y\gets\const{NIL}$
      \li $x\gets\attrib{T}{root}$
      \li \While $x\ne\const{nil}$
      \li \Do $y\gets x$
      \li     \If $\attrib{z}{key}<\attrib{x}{key}$
      \li     \Then $x\gets\attrib{x}{left}$
      \li     \Else $x\gets\attrib{x}{right}$
      \End
      \End
      \li $\attrib{z}{parent}\gets y$
      \li \If $y\isequal \const{NIL}$
      \li \Then \Comment Tree $T$ was empty
      \li        $\attrib{T}{root}\gets z$
      \li \ElseIf $\attrib{z}{key}<\attrib{y}{key}$
      \li       \Then $\attrib{y}{left}\gets z$
      \li       \Else $\attrib{y}{right}\gets z$
      \End
      \End
      \end{codebox}}
\end{small}
\end{center}
    \end{column}
    \begin{column}{5cm}
      \begin{center}
      \includegraphics[width=5cm]{Figures/05-bstinsertion.pdf}
      \end{center}
    \end{column}
  \end{columns}

\note{$x$ trace le chemin, $y$ maintient le pointeur vers le parent de $x$.}
\end{frame}

\begin{frame}{Suppression}

3 cas à considérer en fonction du n\oe ud $z$ à supprimer:
\begin{itemize}
\item $z$ n'a pas de fils gauche: remplacer $z$ par son fils droite
\centerline{\includegraphics[width=5cm]{Figures/05-bstdelete-1.pdf}}
\item $z$ n'a pas de fils droit: remplacer $z$ par son fils gauche
\centerline{\includegraphics[width=5cm]{Figures/05-bstdelete-2.pdf}}
\end{itemize}

\end{frame}

\begin{frame}
\begin{itemize}
\item $z$ a deux fils: rechercher le successeur $y$ de $z$.\\\emph{NB: $y$ est dans le sous-arbre de droite et n'a pas de fils gauche.}
\begin{itemize}
\item Si $y$ est le fils droit de $z$, remplacer $z$ par $y$ et conserver le fils droit de $y$
\centerline{\includegraphics[width=5.5cm]{Figures/05-bstdelete-3.pdf}}
\item Sinon, $y$ est dans le sous-arbre droit de $z$ mais n'en est pas la racine. On remplace $y$ par son propre fils droit et on remplace $z$ par $y$.
\centerline{\includegraphics[width=8.5cm]{Figures/05-bstdelete-4.pdf}}
\end{itemize}
\end{itemize}
\note{$y$ n'a pas de fils gauche sinon, le successeur de $z$ se trouverait dans le sous-arbre de gauche qui correspond à des valeurs plus petites que $y$ et plus grande que $z$.
~\\
}
\end{frame}

\begin{frame}{Suppression}
\vspace{-1cm}
\begin{columns}
\begin{column}{6cm}
\begin{center}
\begin{small}
\fcolorbox{white}{Lightgray}{%
  \begin{codebox}
    \Procname{$\proc{Tree-Delete}(T,z)$}
    \li \If $\attrib{z}{left}\isequal \const{NIL}$
    \li \Then $\proc{Transplant}(T,z,z.right)$
    \li \ElseIf $\attrib{z}{right}\isequal\const{NIL}$
    \li \Then $\proc{Transplant}(T,z,z.left)$
    \li \Else \Comment $z$ has two children
    \li $y\gets\proc{Tree-Successor}(z)$
    \li \If $\attrib{y}{parent}\ne z$
    \li \Then $\proc{Transplant}(T,y,y.right)$
    \li $\attrib{y}{right}\gets\attrib{z}{right}$
    \li $\attrib{y}{right}.\id{parent} \gets y$
    \End
    \li \Comment Replace $z$ by $y$
    \li $\proc{Transplant}(T,z,y)$
    \li $\attrib{y}{left}\gets \attrib{z}{left}$
    \li $\attrib{y}{left}.\id{parent}\gets y$
    \End
\end{codebox}}
\end{small}
\end{center}
\end{column}
\begin{column}{6cm}

\bigskip

\bigskip

\begin{center}
\begin{small}
\fcolorbox{white}{Lightgray}{%
  \begin{codebox}
    \Procname{$\proc{Transplant}(T,u,v)$}
    \li\If $\attrib{u}{parent}\isequal \const{NIL}$
    \li\Then $\attrib{T}{root}\gets v$
    \li \ElseIf $u\isequal \attrib{u}{parent}.\id{left}$
    \li \Then $\attrib{u}{parent}.\id{left}\gets v$
    \li \Else $\attrib{u}{parent}.\id{right}\gets v$
    \End
    \li \If $v\ne\const{NIL}$
    \li \Then $\attrib{v}{parent}=\attrib{u}{parent}$
    \End
  \end{codebox}}
\end{small}
\end{center}

\end{column}
\end{columns}

Complexité: $O(h)$ pour un arbre de hauteur $h$\\(Tout est $O(1)$ sauf l'appel à $\proc{Tree-Successor}$).
\end{frame}

\begin{frame}{Arbres binaires de recherche}

\begin{itemize}
\item Toutes les opérations sont $O(h)$ où $h$ est la hauteur de l'arbre
\item Si $n$ éléments ont été insérés dans l'arbre:
\begin{itemize}
\item Au pire, $h=n-1=O(n)$
\begin{itemize}
\item Elements insérés en ordre
\end{itemize}
\item Au mieux, $h=\lceil\log_2 n\rceil=O(\log n)$
\begin{itemize}
\item Pour un arbre binaire complet
\end{itemize}
\item En moyenne, on peut montrer que $h=O(\log n)$
\begin{itemize}
\item En supposant que les éléments ont été insérés en ordre aléatoire
\end{itemize}
\end{itemize}
\item Problème:  le pire cas n'est pas rare

\bigskip

\item Deux solutions:
\begin{itemize}
\item Utiliser de la randomisation pour que le probabilité de rencontrer le pire cas soit négligeable
\item Maintenir les arbres équilibrés
\end{itemize}
\end{itemize}
\note{
randomization: n'assure pas qu'on ne sera jamais dans le pire cas. Suppose qu'on puisse jouer sur l'ordre d'insertion

Peut-être développer un peu l'insertion sur base des slides de Carzinaga...
}
\end{frame}

\begin{frame}{Tri avec un arbre binaire de recherche}

\begin{center}
\begin{small}
\fcolorbox{white}{Lightgray}{%
  \begin{codebox}
    \Procname{$\proc{Binary-Search-Tree-Sort}(A)$}
    \li $T\gets$ ``Empty binary search tree''
    \li \For $i\gets 1$ \To $n$
    \li \Do $\proc{Tree-Insert}(T,A[i])$\End
    \li $\proc{Inorder-Tree-Walk}(\attrib{T}{root})$
    \End
  \end{codebox}
  }
\end{small}
\end{center}

\begin{itemize}
\item Exemple: $A=[6,5,7,2,5,8]$

~\hfill\includegraphics[width=5cm]{Figures/05-onebst.pdf}
\item Complexité en temps identique au quicksort
\begin{itemize}
\item Insertion: en moyenne, $n\cdot O(\log n)=O(n\log n)$, pire cas: $O(n^2)$
\item Parcours de l'arbre en ordre: $O(n)$
\item Total: $O(n\log n)$ en moyenne, $O(n^2)$ pour le pire cas
\end{itemize}
\item Complexité en espace cependant plus importante, pour le stockage de la structure d'arbres.
\end{itemize}

\end{frame}

\begin{frame}{Arbres équilibrés}
\begin{itemize}
\item Solution générale pour obtenir une complexité au pire cas en $O(n\log n)$:% maintenir en permanence un arbre plus ou moins complet
\begin{itemize}
\item Définir un \alert{invariant} sur la structure d'arbre
\item Prouver que cette invariant garantit une hauteur $\Theta(\log n)$
\item Implémenter les opérations d'insertion et suppression de manière à maintenir l'invariant
\item Si ces opérations ne sont pas trop coûteuse (p.ex., $O(\log
  n)$), on aura gagné
\end{itemize}

\bigskip

\item Plusieurs types d'arbres équilibrés:
\begin{itemize}
\item Arbres AVL
\begin{itemize}
\item Invariant: Arbres $H$-équilibrés
\end{itemize}
\item Arbres 2-3-4
\item Arbres rouges et noirs
\item Splay trees, Scapegoat trees, treaps,\ldots
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Arbres $H$-équilibrés}
\begin{itemize}
\item \alert{Définition:}

$$T\mbox{ est }H-\mbox{équilibré}\Leftrightarrow |h(g(T'))-h(d(T'))|\leq 1,$$
pour tout sous-arbre $T'$ de $T$, et où $g(X)$, $d(X)$ et $h(X)$ sont resp. le sous-arbre gauche, le sous-arbre droit et la hauteur de l'arbre $X$.

\medskip

\emph{(Les hauteurs des deux sous-arbres d'un même n\oe ud diffèrent au plus de un)}

\bigskip

\item \alert{Propriété:}

Pour tout arbre $H$-équilibré de taille $n$ et de hauteur $h$, on a 
$$h=\Theta(\log n)$$

Plus précisément, on peut prouver:
 $$\log(n+1)\leq h+1< 1,44 \log(n+2)$$
\end{itemize}

\end{frame}

\begin{frame}{Arbres $H$-équilibrés}
\alert{Démonstration}

Etant donné un arbre $H$-équilibré de taille $n$ et de hauteur $h\geq 1$, pour $h$ fixé, $n$ est
\begin{itemize}
\item Maximum: quand l'arbre est complet, soit quand
$n=2^{h+1}-1\Rightarrow n+1\leq 2^{h+1} \Rightarrow \log (n+1)\leq h+1$
\item Minimum: quand $n=N(h)$ où $N(h)$ est la taille d'un arbre $H$-équilibré de hauteur $h$ qui a le moins d'éléments.
\begin{itemize}
\item $N(h)$ peut être défini par récurrence par $N(h)=1+N(h-1)+N(h-2)$ avec $N(0)=1$ et $N(1)=2$.
\end{itemize}
\end{itemize}
\centerline{\includegraphics[width=5cm]{Figures/05-avlmaximum.pdf}}
\end{frame}

\begin{frame}{~}%{Borne plus simple}
\begin{itemize}
\item[]
\begin{itemize}
\item On a donc\\
\begin{tabular}{cl}
& $N(h)=1+N(h-1)+N(h-2)$\\
$\Rightarrow$ & $N(h)>2 N(h-2)$ (car $N(h-1)>N(h-2)$)\\
$\Rightarrow$ & $N(h)>2^{h/2}$\\
$\Rightarrow$ & $h< 2\log N(h)$\\
\end{tabular}
\end{itemize}
\item On en déduit que
$$h=\Theta(\log n)$$\qed
\end{itemize}

\end{frame}

\begin{frame}{Borne supérieure plus précise}
\begin{itemize}
\item[]
\begin{itemize}
\item En notant $F(h)=N(h)+1$, on a $F(h)=F(h-1)+F(h-2)$ avec $F(0)=2$, $F(1)=3$
\item $F$ est un récurrence de Fibonacci qui a pour solution
 $$F(h)=\frac{1}{\sqrt{5}} (\phi^{h+3}-\phi'^{h+3})\mbox{ avec }\phi=\frac{1+\sqrt{5}}{2}\mbox{ et }\phi'=\frac{1-\sqrt{5}}{2}$$
\item On a $$N(h)+1=\frac{1}{\sqrt{5}} (\phi^{h+3}-\phi'^{h+3})$$
\item ce qui donne
$$n+1\geq \frac{1}{\sqrt{5}} (\phi^{h+3}-\phi'^{h+3})> \frac{1}{\sqrt{5}} (\phi^{h+3}-1)$$
(car $|\phi'|<1$)
\item En prenant le $\log_{\phi}$ des deux membres:
$$h+1<1,44\log (n+2)$$
\end{itemize}
%A VERIFIER
\end{itemize}

\end{frame}

\begin{frame}{Arbres AVL}

\begin{itemize}
\item \alert{Définition:} Un arbre AVL est un arbre binaire de
  recherche $H$-équilibré
\item Inventé par Adelson-Velskii et Landis en 1960
\item Recherche:
\begin{itemize}
\item Par la fonction $\proc{Tree-Search}$ puisque c'est un arbre binaire
\item Complexité $\Theta(\log n)$ étant donné la propriété
\end{itemize}
\item Insertion:
\begin{itemize}
\item On insère l'élément comme dans un arbre binaire classique
\item On vérifie que l'invariant soit respecté
\item Si ce n'est pas le cas, on modifie l'arbre
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Rotations}

\centerline{\includegraphics[width=10cm]{Figures/05-rotations.pdf}}

\bigskip

\begin{center}
\fcolorbox{white}{Lightgray}{%
    \begin{codebox}
      \Procname{$\proc{Left-Rotate}(x)$}
      \li $r\gets\attrib{x}{right}$
      \li $\attrib{x}{right}\gets\attrib{r}{left}$
      \li $\attrib{r}{left}\gets x$
      \li \Return $r$
    \end{codebox}}
~~~~~~~~~~~~~~~~~~~
\fcolorbox{white}{Lightgray}{%
    \begin{codebox}
      \Procname{$\proc{Right-Rotate}(x)$}
      \li $l\gets\attrib{x}{left}$
      \li $\attrib{x}{left}\gets\attrib{l}{right}$
      \li $\attrib{l}{right}\gets x$
      \li \Return $l$
    \end{codebox}}
\end{center}

Les rotations maintiennent la propriété d'arbre binaire  de recherche

\note{Deux types d'opération pour maintenir l'équilibre: rotations à gauche et à droite. Implémentée comme sur ce slide. Opération d'ordre $O(1)$.

\bigskip

Donner un exemple: $>1-2-3 \Rightarrow 1->2-3$ où $>$ indique la racine}
\end{frame}

\begin{frame}{Insertion dans un AVL}

\centerline{\includegraphics[width=10cm]{Figures/05-avlinsertion.pdf}}

\bigskip

\begin{itemize}
\item Insérer le nouvel élément comme dans un arbre binaire de recherche ordinaire
\item L'insertion peut créer un déséquilibre (l'arbre n'est plus $H$-équilibré)
\item Remonter depuis le nouveau n\oe ud jusqu'à la racine en
  restaurant l'équilibre des sous-arbres rencontrés si nécessaire
\end{itemize}

\note{Implémentation récursive:
%voir ici:http://www.enseignement.polytechnique.fr/profs/informatique/Luc.Maranget/421/poly/arbre-bin.html
}

\end{frame}

% Insertion:
% - si l'arbre est équilibré -> pas de risque de déséquilibrage
% - si déséquilibre à gauche ou à droite -> possibilité de violation dans le cas d'une insertion à droite ou à gauche
% - symétrique:
%   deux cas: 1) -> 1 rotation corrige le tir
%             2) -> 2 rotations corrigent le tir

% Implémentation: on doit maintenir la hauteur des noeuds (data augmentation)
% Au plus 2 rotations par insertion: Intuitivement, les opérations du slide précédent font que la hauteur du sous-arbre en $x$ n'est finalement pas augmentée suite à l'insertion. Tous les sous-arbres au dessus de $x$ sont maintenus équilibrés (et $x$ est le premier sous-arbre non $H$-équilibré).

% Deletion: idem mais plus de rotations sont possibles

\begin{frame}{Equilibrage}

\begin{itemize}
\item Soit $x$ le n\oe ud le plus bas violant l'invariant après l'insertion
  \begin{itemize}
  \item Tous ses sous-arbres sont $H$-équilibrés
  \item Il y a une différence d'au plus 2 niveaux entre ses
    sous-arbres gauche et droit
  \end{itemize}
\item Comment rétablir l'équilibre ?
\item Deux cas possibles (selon insertion à droite ou à gauche):
\end{itemize}
\begin{center}
Cas 1\hspace{4cm}Cas 2

\medskip

\includegraphics[width=8cm]{Figures/05-avlcas1-2.pdf}

\medskip
(Déséquilibre à droite)\hspace{1.3cm}(Déséquilibre à gauche)
\end{center}

\note{Tous ses sous-arbres sont $H$-équilibrés puisque c'est le plus bas qui viole l'invariant}

\end{frame}

\begin{frame}{Cas 1: déséquilibre à droite}
\begin{itemize}
\item Deux sous-cas possibles
\end{itemize}

\begin{center}
Cas 1.1\hspace{4cm}Cas 1.2

\medskip

\includegraphics[width=8cm]{Figures/05-avlcas1.pdf}

\medskip
(Déséquilibre à l'extérieur)\hspace{1.3cm}(Déséquilibre à l'intérieur)
\end{center}

\bigskip

\emph{(Pourquoi le cas B et C de hauteur $h$ n'est pas possible ?)}

\note{Leur demander pourquoi ce sont les seuls deux cas.

Pourquoi pas B et C de hauteur h ? Parce que sinon, ça voudrait dire que la hauteur du sous-arbre en y a augmenté

}
\end{frame}

\begin{frame}{Cas 1.1: déséquilibre à droite, extérieur}
\begin{itemize}
\item Equilibre rétabli par une rotation à gauche de $x$
\end{itemize}

\begin{center}
\includegraphics[width=10cm]{Figures/05-avleqcas11.pdf}
\end{center}

\end{frame}

\begin{frame}{Cas 1.2: déséquilibre à droite, intérieur}
\begin{itemize}
\item Une rotation à gauche ne permet pas de rétablir l'équilibre
%\end{itemize}

\begin{center}
\includegraphics[width=10cm]{Figures/05-avlcas12-wrong.pdf}
\end{center}
\item Le sous-arbre $B$ contient au moins un élément (l'élément inséré)
\begin{center}
\includegraphics[width=7cm]{Figures/05-avlcas12-decomp.pdf}
\end{center}

\end{itemize}

\end{frame}

\begin{frame}{Cas 1.2: déséquilibre à droite, intérieur}
\begin{itemize}
\item Equilibre rétabli par deux rotations
%\end{itemize}

\begin{center}
\includegraphics[width=10cm]{Figures/05-avlcas12-double.pdf}
\end{center}

\end{itemize}

\end{frame}

\begin{frame}{Cas 2: déséquilibre à gauche}
\begin{itemize}
\item Symétrique du cas 1
\item Deux sous-cas possibles
\end{itemize}

\begin{center}
Cas 2.1\hspace{4cm}Cas 2.2

\medskip

\includegraphics[width=8cm]{Figures/05-avlcas2.pdf}

\medskip
(Déséquilibre à l'extérieur)\hspace{1.3cm}(Déséquilibre à l'intérieur)
\end{center}

\begin{itemize}
\item Résolus respectivement pas une rotation (à droite) et une double rotation.
\end{itemize}

\end{frame}

\begin{frame}{Implémentation}
\begin{itemize}
\item Algorithme récursif: Pour insérer une clé dans un arbre $T$:
\begin{itemize}
\item On l'insère (récursivement) dans le sous-arbre approprié (gauche ou droit)
\item Si l'arbre résultant $T$ devient déséquilibré, on effectue une rotation simple ou double selon le cas dans lequel on se trouve
\end{itemize}
\item L'arbre après rééquilibrage étant de la même hauteur qu'avant l'insertion, on aura à faire qu'au plus une rotation (simple ou double). 
\item L'implémentation est facilitée si on maintient en chaque n\oe ud $x$ un attribut $\attrib{x}{h}$ avec la hauteur du sous-arbre en $x$.
\item Complexité:
\begin{itemize}
\item $O(h)$ où $h$ est la hauteur de l'arbre,
\item c'est-à-dire $O(\log n)$ vu que l'arbre est $H$-équilibré.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Suppression}
\begin{itemize}
\item Comme pour l'insertion, on doit rétablir l'équilibre suite à la suppression
\item La suppression d'un n\oe ud peut déséquilibrer le parent de ce n\oe ud
\item Contrairement à l'insertion, on peut devoir rééquilibrer plusieurs ancêtres du n\oe ud supprimé.
\item Chaque rotation étant d'ordre $O(1)$, la complexité d'une suppression reste cependant $O(h)$ pour un arbre de hauteur $h$ et donc $O(\log n)$ pour un AVL.
\end{itemize}
\end{frame}

\begin{frame}{Tri avec un AVL}

\begin{itemize}
\item Comme avec un arbre de binaire de recherche ordinaire, on peut trier avec un AVL
\begin{itemize}
\item On insère les éléments successivement dans l'arbre
\item On effectue un parcours en ordre de l'arbre
\end{itemize}
\item Complexité en temps: $\Theta(n\log n)$ (comme pour le tri par tas)
\item Complexité en espace: $\Theta(n)$ (pour la structure d'arbre temporaire)
\item Tas versus AVL:
\begin{itemize}
\item Tas: optimisé pour retrouver et supprimer le minimum (ou le max)
\item AVL: optimisé pour retrouver et supprimer un élément arbitraire 
\item A ELABORER
\end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Liens}
\begin{itemize}
\item Liens:
\begin{small}
\begin{itemize}
\item \url{http://www.csi.uottawa.ca/~stan/csi2514/applets/avl/BT.html}
\item \url{http://www.cs.jhu.edu/~goodrich/dsa/trees/avltree.html}
\end{itemize}
\end{small}
\end{itemize}
\end{frame}

\section{Table de hachage}

\begin{frame}{Résumé}
\begin{itemize}
\item Complexité des différentes opérations dans les BST et les RB-trees
\item Peut-on faire mieux ?
\item Oui, en changeant radicalement la philosophie
\end{itemize}

\end{frame}

\begin{frame}{Tableau à accès direct}

\begin{itemize}
\item On suppose:
\begin{itemize}
\item que chaque élément a une clé tirée d'un univers $U=\{0,1,\ldots,m-1\}$ où $m$ n'est pas trop large
\item qu'il ne peut pas y avoir deux éléments avec la même clé.
\end{itemize}
\item Le dictionnaire est implémenté par un tableau $T[0\ldots m-1]$:
\begin{itemize}
\item Chaque position dans la table correspond à une clé de $U$.
\item S'il y a un élément $x$ avec la clé $k$, alors $T[k]$ contient un pointeur vers $x$.
\item Sinon, $T[k]$ est vide ($T[k]=\const{NIL}$).
\end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Tableau à accès direct}

\centerline{\includegraphics[width=9cm]{Figures/05-directtable.pdf}}

\begin{center}
\begin{small}
\fcolorbox{white}{Lightgray}{%
  \begin{codebox}
    \Procname{$\proc{Direct-Address-Search}(T,x)$}
    \li \Return $T[k]$
\end{codebox}}

\fcolorbox{white}{Lightgray}{%
  \begin{codebox}
    \Procname{$\proc{Direct-Address-Insert}(T,x)$}
    \li \Return $T[\attrib{x}{key}]=x$
\end{codebox}}

\fcolorbox{white}{Lightgray}{%
  \begin{codebox}
    \Procname{$\proc{Direct-Address-Delete}(T,x)$}
    \li \Return $T[\attrib{x}{key}]=\const{NIL}$
\end{codebox}}
\end{small}
\end{center}


\end{frame}

\begin{frame}{Tableau à accès direct}

\begin{itemize}
\item Complexité de toutes les opérations: $O(1)$
\item Problème:
\begin{itemize}
\item Complexité en espace: $\Theta(|U|)$
\item si l'univers de clés $U$ est large, stocker une table de taille $|U|$ peut être peu pratique, voire impossible
\end{itemize}
\item Souvent l'ensemble des clés réellement stockées, noté $K$, est petit comparé à $U$ et donc l'espace alloué est gaspillé.

\bigskip\bigskip

\item Comment bénéficier de l'accès rapide d'une table à accès direct avec une table de taille raisonnable ?\\

\medskip

$\Rightarrow$ \alert{Table de hachage:}
\begin{itemize}
\item Réduit le stockage à $\Theta(|K|)$
\item Recherche en $O(1)$ (\alert{en moyenne} !)
\end{itemize}
\end{itemize}
\note{Le prix à payer est qu'on a plus une complexité en $O(1)$ dans le pire cas mais en moyenne. Ce qui n'est pas un problème}
\end{frame}

\begin{frame}{Table de hachage}

\begin{itemize}
\item Idée:
\begin{itemize}
\item Utiliser une table $T$ de taille $m<<|U|$
\item stocker $x$ à la position $h(\attrib{x}{key})$, où $h$ est une fonction de \alert{hachage}: $$                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         