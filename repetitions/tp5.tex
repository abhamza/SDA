\documentclass[a4paper,10pt]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{array}
\usepackage{../clrscode3epg}
\renewcommand{\labelenumi}{(\alph{enumi})}

% Style
\parskip=\smallskipamount

% En-têtes
\title{
    \textbf{Structures de données et algorithmes}\\
    Répétition 5: Tables de hachage et tas
}

\author{Gilles \textsc{Louppe} -- \url{http://www.montefiore.ulg.ac.be/~glouppe}}
\date{22 mars 2013}

% Corps
\begin{document}
\maketitle

\section*{Exercice 1}

Soit une table de hachage \texttt{T} initialement vide, d'une capacité de 11 éléments et dont les collisions sont gérées au moyen de listes simplement liées. Illustrer graphiquement l'insertion des clés $$\{23, 56, 44, 13, 88, 94, 16, 27, 9\}.$$ La fonction de hachage utilisée est la fonction $$h(k) = (2k + 5) \mod 11.$$

\section*{Exercice 2}

Dans le JDK1.1, la fonction de hachage d'une chaîne de caractères était implémentée de la façon suivante. Quel est le défaut de cette fonction?

\begin{verbatim}
public int hashCode() {
    int hash = 0;
    int skip = length() / 8;
    for (int i = 0; i < length(); i = i + skip) {
        hash = (hash * 37) + charAt(i);
    }
    return hash;
}
\end{verbatim}

\section*{Exercice 3}

Désormais, la fonction de hachage d'une chaîne de caractère est implémentée en Java de la façon suivante:

\begin{verbatim}
public int hashCode() {
    int hash = 0;
    for (int i = 0; i < length(); i++) {
        hash = (hash * 31) + charAt(i);
    }
    return hash;
}
\end{verbatim}

Trouvez des chaînes de caractères de longueur $N$ produisant le même hash.

\section*{Exercice 4}

Soient deux ensembles $S$ et $T$ de valeurs quelconques.

\begin{enumerate}
\item Proposer une structure pour représenter un ensemble.
\item Proposer un algorithme qui teste si $S$ est un sous-ensemble de $T$. Analyser sa complexité.
\end{enumerate}


\section*{Exercice 5}

Dessiner tous les tas-\textsc{min} possibles avec l'ensemble des clés $\{A, B, C, D, E\}$, où chaque clé n'apparaît qu'une seule fois.

\section*{Exercice 6}

Soit un tas-\textsc{min} \texttt{H}. Illustrer l'exécution des opérations suivantes:

\begin{verbatim}
heapInsert(H, 5)
heapInsert(H, 4)
heapInsert(H, 7)
heapInsert(H, 1)
heapExtractMin(H)
heapInsert(H, 3)
heapInsert(H, 6)
heapExtractMin(H)
heapExtractMin(H)
heapInsert(H, 8)
heapExtractMin(H)
heapInsert(H, 2)
heapExtractMin(H)
heapExtractMin(H)
\end{verbatim}

\section*{Exercice 7}

\begin{enumerate}
\item Comment implémenter une pile au moyen d'une file à priorité?
\item Comment implémenter une file au moyen d'une file à priorité?
\item Comment implémenter une file aléatoire au moyen d'une file à priorité?
\end{enumerate}





\end{document}
