\documentclass[a4paper,10pt]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{array}
\usepackage{../clrscode3epg}
\renewcommand{\labelenumi}{(\alph{enumi})}

% Style
\parskip=\smallskipamount

% En-têtes
\title{
    \textbf{Structures de données et algorithmes}\\
    Répétition 2: Complexité
}

\author{Gilles \textsc{Louppe} -- \url{http://www.montefiore.ulg.ac.be/~glouppe}}
\date{15 février 2013}

% Corps
\begin{document}
\maketitle

\section*{Exercice 1}

\begin{enumerate}

\item L'algorithme $A$ nécessite $10n^3$ opérations pour résoudre un problème.
L'algorithme $B$ résoud le même problème en $1000n^2$ opérations. Quel est
l'algorithme le plus rapide?

\item L'algorithme $A$ nécessite $32n \log_2 n$ opérations pour résoudre un
problème.  L'algorithme $B$ résoud le même problème en $3n^2$ opérations. Quel
est l'algorithme le plus rapide?

\end{enumerate}

\section*{Exercice 2}

Soit un algorithme dont le temps d'exécution pour $N=1000$, $2000$, $3000$ et
$4000$ est respectivement de $5s$, $20s$, $45s$ et $80s$. Estimez le temps
d'exécution pour $N=5000$.

\section*{Exercice 3}

Classer ces fonctions par ordre croissant de complexité (selon l'opérateur
$O(.)$).

\begin{center}
\begin{tabular}{llll}
    $n \log_2 n$ & $\frac{4}{n}$ & $\sqrt{n}$ & $2^{2^n}$ \\\\
    $\log_2 \log_2 n$ & $8n^3$ & $8^{\ln n}$ & $\frac{n}{2+n}$ \\\\
    $\log_2 n^7$ & $5^{\ln \log_2 n}$ & $(\log_2 n)^3$ & $\frac{n}{\log_2 (2+n)}$
\end{tabular}
\end{center}

\section*{Exercice 4}

\begin{enumerate}

\item Expliquer pourquoi la phrase \textit{"Le temps d'exécution d'un algorithme $A$ est au moins $O(n^2)$"} n'a aucun sens.

\item Donner un exemple de fonction $f(n)$ qui ne soit ni $O(n)$ ni $\Omega(n)$.

\item Montrer que le temps d'exécution d'un algorithme est $\Theta(g(n))$ si et seulement si le temps d'exécution du pire cas est $O(g(n))$ et le temps d'exécution du meilleur cas est $\Omega(g(n))$.

\end{enumerate}

\section*{Exercice 5}

Pour chacun des pseudo-codes suivants, déterminer ce que fait l'algorithme, puis
la complexité asymptotique (en termes de $O(.)$ et de $n$).

\vspace{10pt}
\begin{codebox}
    \Procname{$\proc{Code1}(n)$}
    \li $limit\gets n*n$
    \li $sum\gets 0$
    \li \For $i\gets 1$ \To $limit$
    \li \Do $sum\gets sum+1$
        \End
    \li \Return $sum$
    \End
\end{codebox}
\vspace{10pt}

\begin{codebox}
    \Procname{$\proc{Code2}(n)$}
    \li $i\gets 1$
    \li $limit\gets n*n*n$
    \li $sum\gets 0$
    \li \While $i < limit$
    \li \Do $sum\gets sum+1$
    \li     $i\gets i*2$
        \End
    \li \Return $sum$
    \End
\end{codebox}
\vspace{10pt}

\begin{codebox}
    \Procname{$\proc{Code3}(n)$}
    \li $limit\gets n*n$
    \li $sum\gets 0$
    \li \For $i\gets 1$ \To $limit$
    \li \Do \For $j\gets 1$ \To $i$
    \li     \Do $sum\gets sum+1$
            \End
        \End
    \li \Return $sum$
    \End
\end{codebox}
\vspace{10pt}

\begin{codebox}
    \Procname{$\proc{Code4}(n)$}
    \li \If $n < 1$
        \Then
    \li     \Return n
    \li \Else
    \li     \Return \textsc{Code4}(n - 1) + \textsc{Code4}(n - 1)
       \End
\end{codebox}
\vspace{10pt}

\begin{codebox}
    \Procname{$\proc{Code5}(a, b, c, n)$}
    \li \For $i\gets 1$ \To $n$
    \li \Do \For $j\gets 1$ \To $n$
    \li     \Do $a[i][j]\gets 0$
    \li         \For $k\gets 1$ to $n$
    \li         \Do $a[i][j]\gets a[i][j] + b[i][k] * c[k][j]$
                \End
            \End
        \End
    \End
\end{codebox}
\vspace{10pt}

\begin{codebox}
    \Procname{$\proc{Code6}(n)$}
    \li \If $n == 0$
        \Then
    \li     \Return \texttt{""}
    \li \Else
    \li     $tmp\gets \proc{Code6}(n/2)$
    \li     \If $n \% 2 == 0$
            \Then
    \li         \Return tmp + tmp
    \li     \Else
    \li         \Return tmp + tmp + \texttt{"x"}
            \End
       \End
\end{codebox}
\vspace{10pt}

\begin{codebox}
    \Procname{$\proc{Code7}(n)$}
    \li $s\gets$ \texttt{""}
    \li \For $i\gets 1$ \To $n$
    \li \Do $s\gets s+$\texttt{"x"}
        \End
    \li \Return $s$
\end{codebox}
\vspace{10pt}

\section*{Exercice 6}

Supposons que nous avons un tableau $A$ de $n$ valeurs classées dans l'ordre
croissant. On se propose de rechercher si une valeur $b$ est présente dans ce
tableau.

\begin{enumerate}

\item Ecrire le pseudo-code d'un algorithme brutal pour rechercher la valeur
$b$.  Analyser sa complexité dans le meilleur cas et dans le pire cas.

\item Proposer un algorithme dichotomique pour trouver la valeur $b$. Analyser
sa complexité dans le meilleur cas et dans le pire cas.

\end{enumerate}

\textit{Bonus:} Analyser la complexité moyenne de ces algorithmes.

\section*{Exercice 7}

On se propose de coder une fonction polynomiale, de la forme:
$$
p(x) = \sum_{i=0}^n a_i x^i
$$

\begin{enumerate}

\item Quelle est la complexité d'un algorithme implémentant $p(x)$ sous la forme présentée ci-dessus? (En utilisant uniquement des additions et des multiplications.)

\item Proposer un algorithme linéaire.

\end{enumerate}

\section*{Exercice 8}

Une attaque par \textit{déni de service} (DoS) est une attaque visant à saturer
une application de sorte qu'elle ne puisse plus répondre à de nouvelles
requêtes. Typiquement, un pirate essaiera de saturer l'application par une
multiplication de requêtes lourdes en temps de calcul. Un exemple classique est
celui de Apache qui, en 1997, intégrait la fonction suivante:

\begin{verbatim}
void no2slash(char *name) {
    register int x,y;

    for(x=0; name[x];)
        if(x && (name[x-1] == '/') && (name[x] == '/'))
            for(y=x+1;name[y-1];y++)
                name[y-1] = name[y];
        else x++;
}
\end{verbatim}

\begin{enumerate}
\item Que fait cette fonction?
\item Quelle est sa complexité dans le pire des cas?
\item Comment pouvait-on donc faire pour saturer un serveur web Apache?
\item Le patch proposé pour corriger cette faille de sécurité implémentait
\texttt{no2slash} de la façon ci-après. Quelle est la complexité de cette seconde fonction? La faille est-elle corrigée?
\end{enumerate}

\begin{verbatim}
void no2slash(char *name) {
    char *d, *s;

    s = d = name;
    while (*s) {
        if ((*d++ = *s) == '/') {
            do {
                ++s;
            } while (*s == '/');
        }
        else {
            ++s;
        }
    }
    *d = '\0';
}
\end{verbatim}

\section*{Exercice 9}

Soit un tableau de $N$ entiers où chaque entier de l'intervalle $1..N$ apparaît exactement une fois, à l'exception d'un entier apparaîssant 2 fois et d'un entier manquant.
Proposer un algorithme linéaire pour trouver l'entier manquant, en utilisant au plus $O(1)$ d'espace mémoire supplémentaire.

\section*{Exercice 10}

Soit un tableau $N \times N$ de booléens (\texttt{0} ou \texttt{1}). Proposer un algorithme pour trouver le plus grand sous-tableau contigu contenant uniquement des valeurs \texttt{1}.

\textit{Exemple:} Le tableau suivant contient un sous-tableau $6 \times 2$ contigu ne contenant que des \texttt{1}.

\begin{verbatim}
1 0 1 1 1 0 0 0
0 0 0 1 0 1 0 0
0 0 1 1 1 0 0 0
0 0 1 1 1 0 1 0
0 0 1 1 1 1 1 1
0 1 0 1 1 1 1 0
0 1 0 1 1 1 1 0
0 0 0 1 1 1 1 0
\end{verbatim}

\end{document}
